<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Image Toolbox - Online image processing tools including smart compression and format conversion.">
  <meta name="keywords" content="Image Tools, Image Compression, Resize, Format Converter, Online Tools">
  <title>Image Toolbox - Deng Anliang</title>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/assets/images/favicon.png">

  <!-- Stylesheets -->
  <link rel="stylesheet" href="/assets/css/themes.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/components.css">
  <link rel="stylesheet" href="/assets/css/utilities.css">

  <!-- Canonical -->
  <link rel="canonical" href="https://denganliang.com/en/tools/image-toolbox.html">
  <!-- Alternate language -->
  <link rel="alternate" hreflang="zh" href="/tools/image-toolbox.html">
  <link rel="alternate" hreflang="en" href="/en/tools/image-toolbox.html">
  <link rel="alternate" hreflang="x-default" href="/tools/image-toolbox.html">

  <style>
    .toolbox-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    .toolbox-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .toolbox-header h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }

    .toolbox-header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }

    /* Tab Nav */
    .tab-nav {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid var(--border-color);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tab-btn {
      background: transparent;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      color: var(--text-secondary);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      white-space: nowrap;
      transition: all 0.3s ease;
    }

    .tab-btn:hover {
      color: var(--text-primary);
    }

    .tab-btn.active {
      color: var(--accent-color);
      border-bottom-color: var(--accent-color);
    }

    /* Tool Panel */
    .tool-panel {
      display: none;
    }

    .tool-panel.active {
      display: block;
    }

    /* Tool Cards */
    .tool-item {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      margin-bottom: 1.5rem;
    }

    .tool-item h3 {
      margin-bottom: 1rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tool-item h3 .icon {
      font-size: 1.3rem;
    }

    /* IO Group */
    .io-group {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    @media (min-width: 768px) {
      .io-group.two-columns {
        grid-template-columns: 1fr 1fr;
      }
    }

    .io-section {
      display: flex;
      flex-direction: column;
    }

    .io-section label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      font-weight: 500;
    }

    .io-section input[type="text"],
    .io-section input[type="number"],
    .io-section select {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.75rem;
      font-size: 0.95rem;
      color: var(--text-primary);
      width: 100%;
    }

    /* Buttons */
    .btn-group {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .btn {
      background: var(--accent-color);
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      text-align: center;
    }

    .btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .btn-secondary.btn-toggle-active {
      background: var(--accent-color);
      color: #fff;
      border-color: var(--accent-color);
    }

    /* File Upload */
    .file-upload {
      border: 2px dashed var(--border-color);
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 1.5rem;
    }

    .file-upload:hover, .file-upload.drag-over {
      border-color: var(--accent-color);
      background: var(--bg-secondary);
    }

    .file-upload input[type="file"] {
      display: none;
    }

    .preview-container {
      margin-top: 1rem;
      text-align: center;
    }

    .preview-image {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      display: none;
    }

    .split-result-grid {
      display: none;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .split-result-grid.active {
      display: grid;
    }

    .split-result-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .split-result-item img {
      width: 100%;
      aspect-ratio: 1 / 1;
      object-fit: contain;
      background: rgba(0, 0, 0, 0.04);
      border-radius: 6px;
    }

    .split-result-name {
      font-size: 0.85rem;
      line-height: 1.3;
      word-break: break-all;
    }

    .crop-editor {
      display: none;
      margin-top: 1rem;
    }

    .crop-editor.active {
      display: block;
    }

    .crop-canvas-shell {
      border: 1px solid var(--border-color);
      border-radius: 10px;
      overflow: hidden;
      background: var(--bg-secondary);
      margin: 0 auto;
    }

    .crop-canvas-shell canvas {
      display: block;
      width: 100%;
      height: auto;
      cursor: grab;
      touch-action: none;
      user-select: none;
    }

    .crop-canvas-shell canvas.dragging {
      cursor: grabbing;
    }

    .crop-checkline {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
    }

    .crop-checkline input[type="checkbox"] {
      width: auto;
    }

    .ratio-preset-group {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.6rem;
    }

    .ratio-preset-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      border-radius: 8px;
      padding: 0.35rem 0.7rem;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .zoom-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .zoom-row input[type="range"] {
      flex: 1;
    }

    .bg-preview-wrap {
      margin-top: 1rem;
      text-align: center;
    }

    .bg-preview-canvas {
      max-width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background-image:
        linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
        linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
        linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
      background-size: 16px 16px;
      background-position: 0 0, 0 8px, 8px -8px, -8px 0;
      display: none;
    }

    /* Sub Nav */
    .sub-nav {
      position: sticky;
      top: 60px;
      background: var(--bg-primary);
      padding: 1rem 0;
      margin-bottom: 2rem;
      border-bottom: 1px solid var(--border-color);
      z-index: 100;
    }

    .sub-nav-list {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    .sub-nav-item {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.9rem;
      text-decoration: none;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .sub-nav-item:hover {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
      transform: translateY(-2px);
    }

    /* Compression Info */
    .compression-info {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      display: none;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .info-row:last-child {
      margin-bottom: 0;
    }

    .success-text {
      color: #10b981;
      font-weight: 600;
    }

    .error {
      color: #ef4444;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .toolbox-header h1 {
        font-size: 2rem;
      }

      .tab-nav {
        justify-content: flex-start;
      }

      .tool-item {
        padding: 1rem;
      }

      .sub-nav {
        top: 50px;
      }

      .sub-nav-list {
        justify-content: flex-start;
        overflow-x: auto;
        flex-wrap: nowrap;
        -webkit-overflow-scrolling: touch;
      }

      .sub-nav-item {
        white-space: nowrap;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="navbar-content">
      <a href="/en/" class="navbar-logo">Deng Anliang</a>

      <ul class="navbar-menu">
        <li><a href="/en/">Home</a></li>
        <li><a href="/en/about/">About</a></li>
        <li><a href="/en/projects/">Projects</a></li>
        <li><a href="/en/tools/">Tools</a></li>
        <li><a href="/en/blog/">Blog</a></li>
      </ul>

      <div class="navbar-actions">
        <button class="lang-toggle" aria-label="Switch language">‰∏≠Êñá</button>
        <button class="theme-toggle" aria-label="Toggle theme"></button>
      </div>
    </div>
  </nav>

  <!-- Main Content -->
  <main class="main-content">
    <div class="toolbox-container">
      <!-- Header -->
      <div class="toolbox-header">
        <h1>üñºÔ∏è Image Toolbox</h1>
        <p>Integrated tools for image compression, conversion, and more. Pure frontend processing for privacy.</p>
      </div>

      <!-- Tab Nav -->
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="basic-tools">Basic Tools</button>
        <button class="tab-btn" data-tab="video-tools">Video Tools</button>
      </div>

      <!-- Sub Nav -->
      <nav class="sub-nav">
        <div class="sub-nav-list">
          <a href="#compress" class="sub-nav-item">Image Compression</a>
          <a href="#grid-split" class="sub-nav-item">Grid Splitter</a>
          <a href="#resize-crop" class="sub-nav-item">Resize Crop</a>
          <a href="#bg-remove" class="sub-nav-item">Background Removal</a>
          <a href="#video2gif" class="sub-nav-item">Video to GIF</a>
          <a href="#videocompress" class="sub-nav-item">Video Compressor</a>
        </div>
      </nav>

      <!-- Basic Tools Panel -->
      <div class="tool-panel active" id="basic-tools">
        <!-- Compression Tool -->
        <div class="tool-item" id="compress">
          <h3><span class="icon">üìâ</span> Image Compressor</h3>

          <div class="file-upload" id="drop-zone" onclick="document.getElementById('file-input').click()">
            <input type="file" id="file-input" accept="image/jpeg,image/png,image/webp,image/bmp,image/x-ms-bmp,image/gif" onchange="handleFileSelect(event)">
            <div id="upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Load an image</p>
              <p class="hint">Click or drag & drop image here (PNG, JPEG, BMP, GIF, WEBP)</p>
            </div>
            <div class="preview-container">
              <img id="preview-img" class="preview-image">
              <p id="file-info" style="margin-top: 0.5rem; color: var(--text-secondary);"></p>
            </div>
          </div>

          <div class="io-group">
            <div class="io-section">
              <label>Target Size (KB)</label>
              <input type="number" id="target-size" placeholder="e.g. 200" value="200" min="10">
              <p class="hint">JPEG/WEBP use smart target-size compression; PNG/BMP/GIF export at original dimensions.</p>
            </div>

            <div class="io-section">
              <label>New Filename (Optional)</label>
              <input type="text" id="new-filename" placeholder="Leave empty for original name">
            </div>

            <div class="io-section">
              <label>Output Format</label>
              <select id="output-format">
                <option value="image/png">PNG</option>
                <option value="image/jpeg">JPEG</option>
                <option value="image/bmp">BMP</option>
                <option value="image/gif">GIF</option>
                <option value="image/webp">WEBP</option>
              </select>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn" id="compress-btn" onclick="startCompression()" disabled>Start Compress</button>
            <button class="btn btn-secondary" onclick="resetCompressor()">Reset</button>
            <a id="download-link" class="btn" style="display: none; background: #10b981;" download>Download</a>
          </div>

          <div id="result-info" class="compression-info"></div>
          <div id="error-msg" class="error"></div>
        </div>

        <div class="tool-item" id="grid-split">
          <h3><span class="icon">üî≤</span> Grid Splitter</h3>

          <div class="file-upload" id="grid-drop-zone" onclick="document.getElementById('grid-input').click()">
            <input type="file" id="grid-input" accept="image/*" onchange="handleGridSelect(event)">
            <div id="grid-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Upload a grid image</p>
              <p class="hint">Supports 2√ó2, 3√ó3, 4√ó4 and more. Click or drag & drop.</p>
            </div>
            <div class="preview-container">
              <img id="grid-preview-img" class="preview-image">
              <p id="grid-file-info" style="margin-top: 0.5rem; color: var(--text-secondary);"></p>
            </div>
          </div>

          <div class="io-group two-columns">
            <div class="io-section">
              <label>Grid Type</label>
              <select id="grid-layout">
                <option value="2x2">2 √ó 2 (4 pieces)</option>
                <option value="3x3" selected>3 √ó 3 (9 pieces)</option>
                <option value="4x4">4 √ó 4 (16 pieces)</option>
                <option value="5x5">5 √ó 5 (25 pieces)</option>
              </select>
            </div>

            <div class="io-section">
              <label>Output Format</label>
              <select id="grid-output-format">
                <option value="original" selected>Keep original (recommended)</option>
                <option value="image/png">PNG</option>
                <option value="image/jpeg">JPG</option>
                <option value="image/webp">WEBP</option>
              </select>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn" id="grid-split-btn" onclick="startGridSplit()" disabled>Split Image</button>
            <button class="btn btn-secondary" id="grid-download-all-btn" onclick="downloadAllGridPieces()" style="display:none;">Download All</button>
            <button class="btn btn-secondary" onclick="resetGridSplitter()">Reset</button>
          </div>

          <div id="grid-error-msg" class="error"></div>
          <div id="grid-result-info" class="compression-info"></div>
          <div id="grid-result-list" class="split-result-grid"></div>
        </div>

        <div class="tool-item" id="resize-crop">
          <h3><span class="icon">‚úÇÔ∏è</span> Resize Crop (Drag + Zoom)</h3>

          <div class="file-upload" id="crop-drop-zone" onclick="document.getElementById('crop-input').click()">
            <input type="file" id="crop-input" accept="image/*" onchange="handleCropSelect(event)">
            <div id="crop-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Upload an image</p>
              <p class="hint">Set target width/height, then drag and zoom to export exact pixels.</p>
            </div>
            <p id="crop-file-info" style="margin-top: 0.5rem; color: var(--text-secondary);"></p>
          </div>

          <div class="io-group two-columns">
            <div class="io-section">
              <label>Target Width (px)</label>
              <input type="number" id="crop-target-width" value="1080" min="1" step="1">
            </div>
            <div class="io-section">
              <label>Target Height (px)</label>
              <input type="number" id="crop-target-height" value="1080" min="1" step="1">
            </div>
            <div class="io-section">
              <label>Ratio Control</label>
              <label class="crop-checkline">
                <input type="checkbox" id="crop-lock-ratio" checked>
                <span>Lock ratio (link width/height)</span>
              </label>
              <div class="ratio-preset-group">
                <button type="button" class="ratio-preset-btn" data-ratio="1:1">1:1</button>
                <button type="button" class="ratio-preset-btn" data-ratio="4:5">4:5</button>
                <button type="button" class="ratio-preset-btn" data-ratio="16:9">16:9</button>
                <button type="button" class="ratio-preset-btn" data-ratio="9:16">9:16</button>
              </div>
            </div>
            <div class="io-section">
              <label>Output Format</label>
              <select id="crop-output-format" onchange="toggleCropQuality()">
                <option value="image/png" selected>PNG (default)</option>
                <option value="image/jpeg">JPG</option>
                <option value="image/webp">WEBP</option>
              </select>
              <div id="crop-quality-wrap" style="display:none; margin-top: 0.6rem;">
                <label style="font-size:0.85rem; color: var(--text-secondary);">Quality (0.1 - 1)</label>
                <input type="number" id="crop-quality" value="0.92" min="0.1" max="1" step="0.01">
              </div>
            </div>
          </div>

          <div class="io-section">
            <label>Zoom</label>
            <div class="zoom-row">
              <input type="range" id="crop-zoom" min="1" max="5" step="0.01" value="1">
              <span id="crop-zoom-value">100%</span>
            </div>
            <p class="hint">Drag image in crop area to reposition, use wheel or slider to zoom.</p>
          </div>

          <div class="crop-editor" id="crop-editor">
            <div class="crop-canvas-shell" id="crop-canvas-shell">
              <canvas id="crop-canvas"></canvas>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn btn-secondary" id="crop-apply-size-btn" onclick="applyCropTargetSize()" disabled>Apply Size</button>
            <button class="btn btn-secondary" id="crop-fit-btn" onclick="fitCropImage()" disabled>Auto Fit</button>
            <button class="btn btn-secondary" id="crop-center-btn" onclick="centerCropImage()" disabled>Center</button>
            <button class="btn btn-secondary" id="crop-flip-h-btn" onclick="flipCropHorizontal()" disabled>Flip H</button>
            <button class="btn btn-secondary" id="crop-flip-v-btn" onclick="flipCropVertical()" disabled>Flip V</button>
            <button class="btn" id="crop-export-btn" onclick="exportCroppedImage()" disabled>Export Image</button>
            <button class="btn btn-secondary" onclick="resetCropper()">Reset</button>
            <a id="crop-download-link" class="btn" style="display: none; background: #10b981;" download>Download</a>
          </div>

          <div id="crop-error-msg" class="error"></div>
          <div id="crop-result-info" class="compression-info"></div>
        </div>

        <div class="tool-item" id="bg-remove">
          <h3><span class="icon">ü™Ñ</span> Background Removal (Frontend)</h3>

          <div class="file-upload" id="bg-drop-zone" onclick="document.getElementById('bg-input').click()">
            <input type="file" id="bg-input" accept="image/*" onchange="handleBgSelect(event)">
            <div id="bg-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Upload an image</p>
              <p class="hint">Pure frontend method works best on simple/solid backgrounds. Complex scenes are weaker than remove.bg.</p>
            </div>
            <p id="bg-file-info" style="margin-top: 0.5rem; color: var(--text-secondary);"></p>
          </div>

          <div class="io-group two-columns">
            <div class="io-section">
              <label>Threshold (higher removes more)</label>
              <input type="range" id="bg-threshold" min="10" max="180" step="1" value="45">
              <p class="hint">Current: <span id="bg-threshold-value">45</span></p>
            </div>

            <div class="io-section">
              <label>Feather (smoother edges)</label>
              <input type="range" id="bg-feather" min="0" max="120" step="1" value="30">
              <p class="hint">Current: <span id="bg-feather-value">30</span></p>
            </div>

            <div class="io-section">
              <label>Background color source</label>
              <label class="crop-checkline">
                <input type="checkbox" id="bg-use-auto" checked>
                <span>Auto sampling (recommended)</span>
              </label>
              <input type="color" id="bg-color" value="#ffffff" style="margin-top: 0.6rem;">
            </div>

            <div class="io-section">
              <label>Output format</label>
              <select id="bg-output-format">
                <option value="image/png" selected>PNG (recommended for transparency)</option>
                <option value="image/webp">WEBP (transparent)</option>
              </select>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn btn-secondary" id="bg-detect-btn" onclick="detectBgColorOnly()" disabled>Re-sample color</button>
            <button class="btn" id="bg-run-btn" onclick="runBackgroundRemoval()" disabled>Remove Background</button>
            <button class="btn btn-secondary" onclick="resetBgRemoval()">Reset</button>
            <a id="bg-download-link" class="btn" style="display:none; background:#10b981;" download>Download</a>
          </div>

          <div class="bg-preview-wrap">
            <canvas id="bg-result-canvas" class="bg-preview-canvas"></canvas>
            <canvas id="bg-source-canvas" style="display:none;"></canvas>
          </div>

          <div id="bg-error-msg" class="error"></div>
          <div id="bg-result-info" class="compression-info"></div>
        </div>
      </div>

      <!-- Video Tools Panel -->
      <div class="tool-panel" id="video-tools">
        <!-- Video to GIF -->
        <div class="tool-item" id="video2gif">
          <h3><span class="icon">üé¨</span> Video to GIF</h3>

          <div class="file-upload" id="video-drop-zone" onclick="document.getElementById('video-input').click()">
            <input type="file" id="video-input" accept="video/mp4,video/webm" onchange="handleVideoSelect(event)">
            <div id="video-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Load a video</p>
              <p class="hint">Click or drag & drop video here (MP4, WEBM)</p>
            </div>
            <div class="preview-container" style="display:none;" id="video-preview-container">
              <video id="preview-video" controls class="preview-image" style="max-height: 300px;"></video>
              <p id="video-file-info" style="margin-top: 0.5rem; color: var(--text-secondary);"></p>
            </div>
          </div>

          <div class="io-group two-columns">
            <div class="io-section">
              <label>Start Time (s)</label>
              <input type="number" id="gif-start" value="0" min="0" step="0.1">
            </div>
            <div class="io-section">
              <label>Duration (s)</label>
              <input type="number" id="gif-duration" value="3" min="0.1" max="10" step="0.1">
            </div>
            <div class="io-section">
              <label>Width (px)</label>
              <input type="number" id="gif-width" value="300" min="50" max="600">
              <p class="hint">Smaller width means faster generation</p>
            </div>
            <div class="io-section">
              <label>Frame Rate (FPS)</label>
              <input type="number" id="gif-fps" value="10" min="1" max="30">
            </div>
            <div class="io-section">
              <label>Quality (1-10)</label>
              <input type="number" id="gif-quality" value="10" min="1" max="30">
              <p class="hint">Lower is better quality, but slower</p>
            </div>
            <div class="io-section">
              <label>Add Text (Optional)</label>
              <input type="text" id="gif-text" placeholder="Add text at bottom">
            </div>
          </div>

          <div class="btn-group">
            <button class="btn" id="generate-gif-btn" onclick="generateGif()" disabled>Generate GIF</button>
            <button class="btn btn-secondary" onclick="resetVideo()">Reset</button>
            <a id="gif-download-link" class="btn" style="display: none; background: #10b981;" download>Download GIF</a>
          </div>

          <div id="gif-progress-container" style="margin-top: 1rem; display: none;">
            <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between;">
              <span id="gif-status-text">Processing...</span>
              <span id="gif-progress-text">0%</span>
            </div>
            <div style="height: 10px; background: var(--bg-secondary); border-radius: 5px; overflow: hidden;">
              <div id="gif-progress-bar" style="height: 100%; width: 0%; background: var(--accent-color); transition: width 0.3s;"></div>
            </div>
          </div>

          <div id="gif-result-container" class="preview-container" style="display: none; margin-top: 1.5rem;">
            <img id="generated-gif" class="preview-image">
            <p style="margin-top: 0.5rem; color: var(--text-secondary);">Preview</p>
          </div>
        </div>

        <!-- Video Compression -->
        <div class="tool-item" id="videocompress">
          <h3><span class="icon">üíæ</span> Video Compressor</h3>

          <div class="file-upload" id="vc-drop-zone" onclick="document.getElementById('vc-input').click()">
            <input type="file" id="vc-input" accept="video/mp4,video/webm,video/avi,video/x-matroska,video/quicktime" onchange="handleVcSelect(event)">
            <div id="vc-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Load a video</p>
              <p class="hint">Click or drag & drop video here (MP4, WEBM, AVI, MKV, MOV)</p>
            </div>
            <div class="preview-container" style="display:none;" id="vc-preview-container">
              <div style="display: flex; gap: 1rem; align-items: flex-start; justify-content: center; flex-wrap: wrap;">
                 <video id="vc-preview-video" controls class="preview-image" style="max-height: 200px; width: auto; max-width: 100%;"></video>
                 <div style="text-align: left; font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem;">
                   <p id="vc-file-info"></p>
                   <p id="vc-file-meta"></p>
                 </div>
              </div>
            </div>
          </div>

          <div class="io-group two-columns">
            <div class="io-section">
              <label>Target Format</label>
              <select id="vc-format">
                <option value="mp4">MP4</option>
                <option value="webm">WEBM</option>
              </select>
            </div>

             <div class="io-section">
              <label>Resolution</label>
              <select id="vc-resolution" onchange="toggleVcResolution()">
                <option value="original">Keep Original</option>
                <option value="1080p">1080p (1920x1080)</option>
                <option value="720p">720p (1280x720)</option>
                <option value="480p">480p (854x480)</option>
                <option value="custom">Custom...</option>
              </select>
              <div id="vc-custom-res" style="display:none; margin-top: 0.5rem; gap: 0.5rem; align-items: center;">
                 <input type="number" id="vc-width" placeholder="W" style="width: 80px; padding: 0.5rem;"> x
                 <input type="number" id="vc-height" placeholder="H" style="width: 80px; padding: 0.5rem;">
              </div>
            </div>

            <div class="io-section">
              <label>Compression Mode</label>
              <select id="vc-mode" onchange="toggleVcMode()">
                 <option value="crf">Quality Based (CRF)</option>
                 <option value="bitrate">Target Bitrate</option>
              </select>
            </div>

            <div class="io-section" id="vc-crf-group">
              <label>CRF Value (0-51)</label>
              <input type="number" id="vc-crf" value="23" min="0" max="51">
              <p class="hint">Default 23. Lower is better quality, higher is smaller size.</p>
            </div>

            <div class="io-section" id="vc-bitrate-group" style="display:none;">
              <label>Bitrate (kbps)</label>
              <input type="number" id="vc-bitrate" value="1000" step="100">
              <p class="hint">Recommend 800-2000 kbps for web sharing.</p>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn" id="vc-start-btn" onclick="startVideoCompression(false)" disabled>Start Compress</button>
            <button class="btn btn-secondary" id="vc-test-btn" onclick="startVideoCompression(true)" disabled>Test Convert (First 5s)</button>
            <button class="btn btn-secondary" onclick="resetVc()">Reset</button>
            <a id="vc-download-link" class="btn" style="display: none; background: #10b981;" download>Download Video</a>
          </div>

          <div id="vc-progress-container" style="margin-top: 1rem; display: none;">
            <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between;">
              <span id="vc-status-text">Initializing engine...</span>
              <span id="vc-progress-text">0%</span>
            </div>
            <div style="height: 10px; background: var(--bg-secondary); border-radius: 5px; overflow: hidden;">
              <div id="vc-progress-bar" style="height: 100%; width: 0%; background: var(--accent-color); transition: width 0.3s;"></div>
            </div>
             <p id="vc-log-text" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem; font-family: monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></p>
          </div>

          <div id="vc-result-info" class="compression-info"></div>
          <div id="vc-error-msg" class="error"></div>
        </div>
      </div>
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-social">
        <a href="mailto:i@denganliang.com" aria-label="Email">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M.05 3.555A2 2 0 0 1 2 2h12a2 2 0 0 1 1.95 1.555L8 8.414.05 3.555ZM0 4.697v7.104l5.803-3.558L0 4.697ZM6.761 8.83l-6.57 4.027A2 2 0 0 0 2 14h12a2 2 0 0 0 1.808-1.144l-6.57-4.027L8 9.586l-1.239-.757Zm3.436-.586L16 11.801V4.697l-5.803 3.546Z"/>
          </svg>
        </a>
        <a href="https://github.com/denganliang" target="_blank" rel="noopener" aria-label="GitHub">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
          </svg>
        </a>
        <a href="https://twitter.com/denganliang" target="_blank" rel="noopener" aria-label="Twitter">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057a3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z"/>
          </svg>
        </a>
      </div>

      <ul class="footer-links">
        <li><a href="/en/about/">About</a></li>
        <li><a href="/en/blog/">Blog</a></li>
        <li><a href="/en/projects/">Projects</a></li>
        <li><a href="/en/tools/">Tools</a></li>
      </ul>

      <p style="margin-bottom: 0.5rem;">Contact: <a href="mailto:i@denganliang.com">i@denganliang.com</a></p>
      <p>&copy; 2026 Deng Anliang. All rights reserved.</p>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="/assets/js/theme-switcher.js"></script>
  <script src="/assets/js/i18n.js"></script>
  <script src="/assets/js/main.js"></script>

  <script>
    // ==================== Single Threaded FFmpeg Workaround ====================
    // GitHub Pages doesn't support COOP/COEP headers required for SharedArrayBuffer
    // We must use a single-threaded version of FFmpeg core
    const FFMPEG_SCRIPT_URL = '/assets/vendor/ffmpeg/ffmpeg.min.js';
    const GIF_SCRIPT_URL = '/assets/vendor/gif/gif.js';
    const GIF_WORKER_URL = '/assets/vendor/gif/gif.worker.js';
    const FFMPEG_CORE_URL = '/assets/vendor/ffmpeg/ffmpeg-core.js';
    let ffmpegLibPromise = null;
    let gifLibPromise = null;

    function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        const existing = Array.from(document.querySelectorAll('script')).find(script => script.src === src);
        if (existing) {
          if (existing.dataset.loaded === 'true') {
            resolve();
            return;
          }

          existing.addEventListener('load', () => resolve(), { once: true });
          existing.addEventListener('error', () => reject(new Error(`Failed to load script: ${src}`)), { once: true });
          return;
        }

        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = () => {
          script.dataset.loaded = 'true';
          resolve();
        };
        script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(script);
      });
    }

    function loadFfmpegLib() {
      if (window.FFmpeg) {
        return Promise.resolve(window.FFmpeg);
      }

      if (!ffmpegLibPromise) {
        ffmpegLibPromise = loadScriptOnce(FFMPEG_SCRIPT_URL).then(() => {
          if (!window.FFmpeg) {
            throw new Error('FFmpeg runtime loaded but global not found');
          }
          return window.FFmpeg;
        });
      }

      return ffmpegLibPromise;
    }

    function loadGifLib() {
      if (window.GIF) {
        return Promise.resolve(window.GIF);
      }

      if (!gifLibPromise) {
        gifLibPromise = loadScriptOnce(GIF_SCRIPT_URL).then(() => {
          if (!window.GIF) {
            throw new Error('GIF runtime loaded but global not found');
          }
          return window.GIF;
        });
      }

      return gifLibPromise;
    }

    // ==================== Tab Nav ====================
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Remove active class
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tool-panel').forEach(p => p.classList.remove('active'));

        // Add active class
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');
      });
    });

    // ==================== Sub Nav Scroll ====================
    document.querySelectorAll('.sub-nav-item').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = link.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);

        if (targetElement) {
          // Find parent panel
          const panel = targetElement.closest('.tool-panel');
          if (panel && !panel.classList.contains('active')) {
            const tabId = panel.id;
            const tabBtn = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
            if (tabBtn) tabBtn.click();
          }

          // Scroll to element
          setTimeout(() => {
            const headerOffset = 140;
            const elementPosition = targetElement.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.scrollY - headerOffset;

            window.scrollTo({
              top: offsetPosition,
              behavior: "smooth"
            });
          }, 10);
        }
      });
    });

    // ==================== Drop Zone Handling (Image) ====================
    const dropZone = document.getElementById('drop-zone');

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, unhighlight, false);
    });

    function highlight(e) {
      dropZone.classList.add('drag-over');
    }

    function unhighlight(e) {
      dropZone.classList.remove('drag-over');
    }

    dropZone.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleFiles(files);
    }

    function handleFileSelect(e) {
      const files = e.target.files;
      handleFiles(files);
    }

    const gridDropZone = document.getElementById('grid-drop-zone');

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      gridDropZone.addEventListener(eventName, preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      gridDropZone.addEventListener(eventName, (e) => gridDropZone.classList.add('drag-over'), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      gridDropZone.addEventListener(eventName, (e) => gridDropZone.classList.remove('drag-over'), false);
    });

    gridDropZone.addEventListener('drop', handleGridDrop, false);

    function handleGridDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleGridFiles(files);
    }

    function handleGridSelect(e) {
      const files = e.target.files;
      handleGridFiles(files);
    }

    const cropDropZone = document.getElementById('crop-drop-zone');

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      cropDropZone.addEventListener(eventName, preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      cropDropZone.addEventListener(eventName, () => cropDropZone.classList.add('drag-over'), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      cropDropZone.addEventListener(eventName, () => cropDropZone.classList.remove('drag-over'), false);
    });

    cropDropZone.addEventListener('drop', handleCropDrop, false);

    function handleCropDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleCropFiles(files);
    }

    function handleCropSelect(e) {
      const files = e.target.files;
      handleCropFiles(files);
    }

    const bgDropZone = document.getElementById('bg-drop-zone');

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      bgDropZone.addEventListener(eventName, preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      bgDropZone.addEventListener(eventName, () => bgDropZone.classList.add('drag-over'), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      bgDropZone.addEventListener(eventName, () => bgDropZone.classList.remove('drag-over'), false);
    });

    bgDropZone.addEventListener('drop', handleBgDrop, false);

    function handleBgDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleBgFiles(files);
    }

    function handleBgSelect(e) {
      const files = e.target.files;
      handleBgFiles(files);
    }

    // ==================== Drop Zone Handling (Video) ====================
    const videoDropZone = document.getElementById('video-drop-zone');

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      videoDropZone.addEventListener(eventName, preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      videoDropZone.addEventListener(eventName, (e) => videoDropZone.classList.add('drag-over'), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      videoDropZone.addEventListener(eventName, (e) => videoDropZone.classList.remove('drag-over'), false);
    });

    videoDropZone.addEventListener('drop', handleVideoDrop, false);

    function handleVideoDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleVideoFiles(files);
    }

    function handleVideoSelect(e) {
      const files = e.target.files;
      handleVideoFiles(files);
    }

    // ==================== Image Processing Logic ====================
    let originalImage = null;
    let originalFile = null;

    function getOutputExtByMime(mimeType) {
      if (mimeType === 'image/png') return 'png';
      if (mimeType === 'image/jpeg') return 'jpg';
      if (mimeType === 'image/webp') return 'webp';
      if (mimeType === 'image/gif') return 'gif';
      if (mimeType === 'image/bmp') return 'bmp';
      return 'png';
    }

    function getOriginalMimeForCompression(file) {
      const type = (file && file.type || '').toLowerCase();
      if (type === 'image/jpeg' || type === 'image/png' || type === 'image/webp' || type === 'image/gif') {
        return type;
      }
      if (type === 'image/bmp' || type === 'image/x-ms-bmp') {
        return 'image/bmp';
      }
      return 'image/png';
    }

    function setCompressDefaultOutputFormat(file) {
      const outputSelect = document.getElementById('output-format');
      const originalMime = getOriginalMimeForCompression(file);
      const available = Array.from(outputSelect.options).map(option => option.value);
      outputSelect.value = available.includes(originalMime) ? originalMime : 'image/png';
    }

    function canvasToBlobAsync(canvas, mimeType, quality) {
      return new Promise(resolve => canvas.toBlob(resolve, mimeType, quality));
    }

    function convertCanvasToBmpBlob(canvas) {
      const width = canvas.width;
      const height = canvas.height;
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, width, height);
      const src = imageData.data;

      const rowStride = width * 3;
      const rowPadding = (4 - (rowStride % 4)) % 4;
      const imageSize = (rowStride + rowPadding) * height;
      const fileSize = 54 + imageSize;

      const buffer = new ArrayBuffer(fileSize);
      const view = new DataView(buffer);

      view.setUint8(0, 0x42);
      view.setUint8(1, 0x4D);
      view.setUint32(2, fileSize, true);
      view.setUint32(6, 0, true);
      view.setUint32(10, 54, true);

      view.setUint32(14, 40, true);
      view.setInt32(18, width, true);
      view.setInt32(22, height, true);
      view.setUint16(26, 1, true);
      view.setUint16(28, 24, true);
      view.setUint32(30, 0, true);
      view.setUint32(34, imageSize, true);
      view.setInt32(38, 2835, true);
      view.setInt32(42, 2835, true);
      view.setUint32(46, 0, true);
      view.setUint32(50, 0, true);

      let offset = 54;
      for (let y = height - 1; y >= 0; y--) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          view.setUint8(offset++, src[idx + 2]);
          view.setUint8(offset++, src[idx + 1]);
          view.setUint8(offset++, src[idx]);
        }
        for (let pad = 0; pad < rowPadding; pad++) {
          view.setUint8(offset++, 0);
        }
      }

      return new Blob([buffer], { type: 'image/bmp' });
    }

    async function createCompressionBlob(canvas, outputFormat, quality) {
      if (outputFormat === 'image/bmp') {
        return { blob: convertCanvasToBmpBlob(canvas), mimeType: 'image/bmp' };
      }

      if (outputFormat === 'image/gif') {
        const gifBlob = await canvasToBlobAsync(canvas, 'image/gif');
        if (gifBlob && gifBlob.type === 'image/gif') {
          return { blob: gifBlob, mimeType: 'image/gif' };
        }

        const pngBlob = await canvasToBlobAsync(canvas, 'image/png');
        if (!pngBlob) {
          throw new Error('GIF export is not supported and PNG fallback failed');
        }

        return { blob: pngBlob, mimeType: 'image/png' };
      }

      const blob = await canvasToBlobAsync(canvas, outputFormat, quality);
      if (!blob) {
        throw new Error('This browser does not support this output format');
      }
      return { blob, mimeType: blob.type || outputFormat };
    }

    function handleFiles(files) {
      if (files.length === 0) return;

      const file = files[0];
      if (!file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }

      originalFile = file;
      setCompressDefaultOutputFormat(file);

      // Show file info
      const info = document.getElementById('file-info');
      info.textContent = `Original: ${file.name} (${formatSize(file.size)})`;

      // Preview
      const img = document.getElementById('preview-img');
      const reader = new FileReader();

      reader.onload = function(e) {
        img.src = e.target.result;
        img.style.display = 'block';
        document.getElementById('upload-text').style.display = 'none';

        // Load into Image object
        originalImage = new Image();
        originalImage.src = e.target.result;

        document.getElementById('compress-btn').disabled = false;
        document.getElementById('result-info').style.display = 'none';
        document.getElementById('download-link').style.display = 'none';
        document.getElementById('error-msg').textContent = '';
      }

      reader.readAsDataURL(file);
    }

    function formatSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async function startCompression() {
      if (!originalImage) return;

      const targetSizeKB = parseFloat(document.getElementById('target-size').value);
      if (!targetSizeKB || targetSizeKB <= 0) {
        alert('Please enter a valid target size');
        return;
      }

      const targetSizeBytes = targetSizeKB * 1024;
      const outputFormat = document.getElementById('output-format').value;
      const btn = document.getElementById('compress-btn');

      btn.textContent = 'Processing...';
      btn.disabled = true;

      try {
        // Create Canvas
        const canvas = document.createElement('canvas');
        canvas.width = originalImage.naturalWidth;
        canvas.height = originalImage.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(originalImage, 0, 0);

        const supportsQualityCompression = outputFormat === 'image/jpeg' || outputFormat === 'image/webp';
        let bestResult = null;
        let bestQuality = 1.0;

        if (!supportsQualityCompression) {
          bestResult = await createCompressionBlob(canvas, outputFormat, 1.0);
          bestQuality = 1.0;
        } else {
          let minQ = 0.01;
          let maxQ = 1.0;

          const initialResult = await createCompressionBlob(canvas, outputFormat, 1.0);
          const initialBlob = initialResult.blob;

          if (initialBlob.size <= targetSizeBytes) {
            bestResult = initialResult;
            bestQuality = 1.0;
          } else {
            for (let i = 0; i < 7; i++) {
              const midQ = (minQ + maxQ) / 2;
              const result = await createCompressionBlob(canvas, outputFormat, midQ);
              const blob = result.blob;

              if (blob.size <= targetSizeBytes) {
                bestResult = result;
                bestQuality = midQ;
                minQ = midQ;
              } else {
                maxQ = midQ;
              }
            }

            if (!bestResult) {
              bestResult = await createCompressionBlob(canvas, outputFormat, minQ);
              bestQuality = minQ;
            }
          }
        }

        showResult(
          bestResult.blob,
          bestQuality,
          supportsQualityCompression,
          bestResult.mimeType,
          outputFormat
        );

      } catch (e) {
        console.error(e);
        document.getElementById('error-msg').textContent = 'Error: ' + e.message;
      } finally {
        btn.textContent = 'Start Compress';
        btn.disabled = false;
      }
    }

    function showResult(blob, quality, supportsQualityCompression, actualOutputMime, requestedOutputMime) {
      const resultInfo = document.getElementById('result-info');
      const downloadLink = document.getElementById('download-link');
      const targetSizeKB = parseFloat(document.getElementById('target-size').value);

      // Generate download link
      const url = URL.createObjectURL(blob);
      const outputMime = actualOutputMime || requestedOutputMime || document.getElementById('output-format').value;
      const ext = getOutputExtByMime(outputMime);

      // Determine filename
      let filename = document.getElementById('new-filename').value.trim();
      if (!filename) {
        const originalName = originalFile.name;
        const dotIndex = originalName.lastIndexOf('.');
        if (dotIndex > 0) {
          filename = originalName.substring(0, dotIndex) + '_compressed';
        } else {
          filename = originalName + '_compressed';
        }
      }
      if (!filename.toLowerCase().endsWith('.' + ext)) {
        filename += '.' + ext;
      }

      downloadLink.href = url;
      downloadLink.download = filename;
      downloadLink.style.display = 'inline-block';

      // Show result info
      const compressionRatio = ((1 - (blob.size / originalFile.size)) * 100).toFixed(1);
      const isSuccess = blob.size <= targetSizeKB * 1024;
      const compressionInfo = supportsQualityCompression
        ? `-${compressionRatio}% (Quality: ${(quality * 100).toFixed(0)}%)`
        : `-${compressionRatio}%`;

      let extraNote = '';
      if (!supportsQualityCompression) {
        extraNote += '<div class="info-row"><span>Note:</span><span>This format does not use quality compression</span></div>';
      }
      if (requestedOutputMime === 'image/gif' && outputMime !== 'image/gif') {
        extraNote += '<div class="error">Note: GIF export is not supported in this browser, so it fell back to PNG.</div>';
      }
      if (supportsQualityCompression && !isSuccess) {
        extraNote += '<div class="error">Warning: Cannot compress to target size. Used minimum quality. Suggest resizing the image.</div>';
      }

      resultInfo.innerHTML = `
        <div class="info-row">
          <span>Original Size:</span>
          <span>${formatSize(originalFile.size)}</span>
        </div>
        <div class="info-row">
          <span>Compressed Size:</span>
          <span class="${isSuccess ? 'success-text' : ''}">${formatSize(blob.size)}</span>
        </div>
        <div class="info-row">
          <span>Ratio:</span>
          <span>${compressionInfo}</span>
        </div>
        ${extraNote}
      `;
      resultInfo.style.display = 'block';
    }

    function resetCompressor() {
      document.getElementById('file-input').value = '';
      document.getElementById('preview-img').style.display = 'none';
      document.getElementById('upload-text').style.display = 'block';
      document.getElementById('file-info').textContent = '';
      document.getElementById('compress-btn').disabled = true;
      document.getElementById('result-info').style.display = 'none';
      document.getElementById('download-link').style.display = 'none';
      document.getElementById('error-msg').textContent = '';
      document.getElementById('target-size').value = '200';
      document.getElementById('new-filename').value = '';
      document.getElementById('output-format').value = 'image/png';
      originalImage = null;
      originalFile = null;
    }

    let gridImage = null;
    let gridFile = null;
    let gridSplitResults = [];

    function getGridBaseName(file) {
      const dotIndex = file.name.lastIndexOf('.');
      return dotIndex > 0 ? file.name.substring(0, dotIndex) : file.name;
    }

    function getGridOutputSettings() {
      const output = document.getElementById('grid-output-format').value;
      let mimeType = output === 'original' ? (gridFile ? gridFile.type : 'image/png') : output;

      if (!['image/png', 'image/jpeg', 'image/webp'].includes(mimeType)) {
        mimeType = 'image/png';
      }

      const ext = mimeType === 'image/jpeg' ? 'jpg' : (mimeType === 'image/webp' ? 'webp' : 'png');
      const quality = mimeType === 'image/png' ? undefined : 0.92;

      return { mimeType, ext, quality };
    }

    function clearGridResults() {
      gridSplitResults.forEach(item => URL.revokeObjectURL(item.url));
      gridSplitResults = [];

      const resultList = document.getElementById('grid-result-list');
      resultList.innerHTML = '';
      resultList.classList.remove('active');

      const resultInfo = document.getElementById('grid-result-info');
      resultInfo.innerHTML = '';
      resultInfo.style.display = 'none';

      const downloadAllBtn = document.getElementById('grid-download-all-btn');
      downloadAllBtn.style.display = 'none';
      downloadAllBtn.disabled = false;
      downloadAllBtn.textContent = 'Download All';
    }

    function handleGridFiles(files) {
      if (!files || files.length === 0) return;

      const file = files[0];
      if (!file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }

      clearGridResults();
      gridFile = file;
      document.getElementById('grid-error-msg').textContent = '';

      const reader = new FileReader();
      reader.onload = function(e) {
        const previewImg = document.getElementById('grid-preview-img');
        previewImg.src = e.target.result;
        previewImg.style.display = 'block';
        document.getElementById('grid-upload-text').style.display = 'none';

        gridImage = new Image();
        gridImage.onload = () => {
          document.getElementById('grid-file-info').textContent = `Original: ${file.name} (${formatSize(file.size)}) ¬∑ ${gridImage.naturalWidth}√ó${gridImage.naturalHeight}`;
          document.getElementById('grid-split-btn').disabled = false;
        };
        gridImage.onerror = () => {
          document.getElementById('grid-error-msg').textContent = 'Failed to read image, please try again';
          document.getElementById('grid-split-btn').disabled = true;
          gridImage = null;
        };
        gridImage.src = e.target.result;
      }

      reader.readAsDataURL(file);
    }

    function renderGridSplitResult(rows, cols, ext) {
      const resultInfo = document.getElementById('grid-result-info');
      const resultList = document.getElementById('grid-result-list');
      const downloadAllBtn = document.getElementById('grid-download-all-btn');

      const totalSize = gridSplitResults.reduce((sum, item) => sum + item.size, 0);

      resultInfo.innerHTML = `
        <div class="info-row">
          <span>Grid type:</span>
          <span>${rows} √ó ${cols}</span>
        </div>
        <div class="info-row">
          <span>Pieces:</span>
          <span class="success-text">${gridSplitResults.length}</span>
        </div>
        <div class="info-row">
          <span>Output format:</span>
          <span>${ext.toUpperCase()}</span>
        </div>
        <div class="info-row">
          <span>Total size:</span>
          <span>${formatSize(totalSize)}</span>
        </div>
      `;
      resultInfo.style.display = 'block';

      resultList.innerHTML = '';
      gridSplitResults.forEach(item => {
        const card = document.createElement('div');
        card.className = 'split-result-item';

        const image = document.createElement('img');
        image.src = item.url;
        image.alt = item.name;

        const name = document.createElement('div');
        name.className = 'split-result-name';
        name.textContent = item.name;

        const meta = document.createElement('p');
        meta.className = 'hint';
        meta.style.margin = '0';
        meta.textContent = `${item.width}√ó${item.height} ¬∑ ${formatSize(item.size)}`;

        const downloadLink = document.createElement('a');
        downloadLink.className = 'btn btn-secondary';
        downloadLink.href = item.url;
        downloadLink.download = item.name;
        downloadLink.textContent = 'Download';

        card.appendChild(image);
        card.appendChild(name);
        card.appendChild(meta);
        card.appendChild(downloadLink);
        resultList.appendChild(card);
      });

      resultList.classList.add('active');
      downloadAllBtn.style.display = 'inline-block';
    }

    async function startGridSplit() {
      if (!gridImage || !gridFile) return;

      const splitBtn = document.getElementById('grid-split-btn');
      splitBtn.disabled = true;
      splitBtn.textContent = 'Splitting...';

      document.getElementById('grid-error-msg').textContent = '';
      clearGridResults();

      try {
        const [rows, cols] = document.getElementById('grid-layout').value.split('x').map(Number);
        if (!rows || !cols) {
          throw new Error('Please select a valid grid type');
        }

        if (gridImage.naturalWidth < cols || gridImage.naturalHeight < rows) {
          throw new Error('Image is too small for this grid type');
        }

        const { mimeType, ext, quality } = getGridOutputSettings();
        const baseName = getGridBaseName(gridFile);
        const sourceWidth = gridImage.naturalWidth;
        const sourceHeight = gridImage.naturalHeight;

        let index = 1;
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const sx = Math.floor((sourceWidth * col) / cols);
            const sy = Math.floor((sourceHeight * row) / rows);
            const ex = Math.floor((sourceWidth * (col + 1)) / cols);
            const ey = Math.floor((sourceHeight * (row + 1)) / rows);

            const width = ex - sx;
            const height = ey - sy;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(gridImage, sx, sy, width, height, 0, 0, width, height);

            const blob = await new Promise(resolve => canvas.toBlob(resolve, mimeType, quality));
            if (!blob) {
              throw new Error('Output format is not supported in this browser');
            }

            const name = `${baseName}${index}.${ext}`;
            const url = URL.createObjectURL(blob);

            gridSplitResults.push({
              name,
              url,
              size: blob.size,
              width,
              height
            });

            index++;
          }
        }

        renderGridSplitResult(rows, cols, ext);
      } catch (error) {
        document.getElementById('grid-error-msg').textContent = `Split failed: ${error.message}`;
      } finally {
        splitBtn.disabled = false;
        splitBtn.textContent = 'Split Image';
      }
    }

    async function downloadAllGridPieces() {
      if (gridSplitResults.length === 0) return;

      const downloadAllBtn = document.getElementById('grid-download-all-btn');
      downloadAllBtn.disabled = true;
      downloadAllBtn.textContent = 'Downloading...';

      try {
        for (const item of gridSplitResults) {
          const link = document.createElement('a');
          link.href = item.url;
          link.download = item.name;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          await new Promise(resolve => setTimeout(resolve, 120));
        }
      } finally {
        downloadAllBtn.disabled = false;
        downloadAllBtn.textContent = 'Download All';
      }
    }

    function resetGridSplitter() {
      clearGridResults();

      document.getElementById('grid-input').value = '';
      document.getElementById('grid-preview-img').style.display = 'none';
      document.getElementById('grid-upload-text').style.display = 'block';
      document.getElementById('grid-file-info').textContent = '';
      document.getElementById('grid-error-msg').textContent = '';
      document.getElementById('grid-layout').value = '3x3';
      document.getElementById('grid-output-format').value = 'original';
      document.getElementById('grid-split-btn').disabled = true;

      gridImage = null;
      gridFile = null;
    }

    const cropCanvas = document.getElementById('crop-canvas');
    const cropCanvasCtx = cropCanvas.getContext('2d');
    const cropZoomInput = document.getElementById('crop-zoom');
    const cropZoomValue = document.getElementById('crop-zoom-value');
    const cropTargetWidthInput = document.getElementById('crop-target-width');
    const cropTargetHeightInput = document.getElementById('crop-target-height');
    const cropLockRatioInput = document.getElementById('crop-lock-ratio');
    const cropEditor = document.getElementById('crop-editor');
    const cropCanvasShell = document.getElementById('crop-canvas-shell');

    let cropFile = null;
    let cropImage = null;
    let cropObjectUrl = null;
    let cropDownloadUrl = null;
    let cropTargetWidth = 1080;
    let cropTargetHeight = 1080;
    let cropBaseScale = 1;
    let cropScale = 1;
    let cropOffsetX = 0;
    let cropOffsetY = 0;
    let cropDragging = false;
    let cropDragStartX = 0;
    let cropDragStartY = 0;
    let cropLastPinchDistance = 0;
    let cropAspectRatio = cropTargetWidth / cropTargetHeight;
    let cropFlipX = 1;
    let cropFlipY = 1;

    function parsePositiveInt(value, fallback) {
      const number = parseInt(value, 10);
      return Number.isFinite(number) && number > 0 ? number : fallback;
    }

    function getCropOutputConfig() {
      const type = document.getElementById('crop-output-format').value;
      const qualityInput = parseFloat(document.getElementById('crop-quality').value);
      const quality = Number.isFinite(qualityInput) ? Math.min(1, Math.max(0.1, qualityInput)) : 0.92;
      const ext = type === 'image/jpeg' ? 'jpg' : (type === 'image/webp' ? 'webp' : 'png');
      return { type, quality, ext };
    }

    function toggleCropQuality() {
      const format = document.getElementById('crop-output-format').value;
      document.getElementById('crop-quality-wrap').style.display = format === 'image/png' ? 'none' : 'block';
    }

    function getCropBaseName(file) {
      const dotIndex = file.name.lastIndexOf('.');
      return dotIndex > 0 ? file.name.substring(0, dotIndex) : file.name;
    }

    function syncCropZoomLabel() {
      cropZoomValue.textContent = `${Math.round(cropScale * 100)}%`;
    }

    function syncCropZoomInput() {
      cropZoomInput.value = cropScale.toFixed(4);
      syncCropZoomLabel();
    }

    function getCropCanvasDrawSize() {
      const maxPreviewWidth = Math.min(760, cropCanvasShell.clientWidth || 760);
      let drawWidth = maxPreviewWidth;
      let drawHeight = drawWidth / cropAspectRatio;

      const maxPreviewHeight = 520;
      if (drawHeight > maxPreviewHeight) {
        drawHeight = maxPreviewHeight;
        drawWidth = drawHeight * cropAspectRatio;
      }

      return {
        drawWidth: Math.max(120, Math.round(drawWidth)),
        drawHeight: Math.max(120, Math.round(drawHeight))
      };
    }

    function setCropCanvasSize() {
      const { drawWidth, drawHeight } = getCropCanvasDrawSize();
      cropCanvas.width = drawWidth;
      cropCanvas.height = drawHeight;
      cropCanvas.style.width = `${drawWidth}px`;
      cropCanvas.style.height = `${drawHeight}px`;
    }

    function clampCropOffsets() {
      if (!cropImage) return;
      const renderWidth = cropImage.naturalWidth * cropBaseScale * cropScale;
      const renderHeight = cropImage.naturalHeight * cropBaseScale * cropScale;

      const minOffsetX = cropCanvas.width - renderWidth;
      const minOffsetY = cropCanvas.height - renderHeight;

      cropOffsetX = Math.min(0, Math.max(minOffsetX, cropOffsetX));
      cropOffsetY = Math.min(0, Math.max(minOffsetY, cropOffsetY));
    }

    function drawCropCanvas() {
      cropCanvasCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
      if (!cropImage) {
        cropCanvasCtx.fillStyle = '#888';
        cropCanvasCtx.font = '14px sans-serif';
        cropCanvasCtx.textAlign = 'center';
        cropCanvasCtx.fillText('Upload image first', cropCanvas.width / 2, cropCanvas.height / 2);
        return;
      }

      const renderWidth = cropImage.naturalWidth * cropBaseScale * cropScale;
      const renderHeight = cropImage.naturalHeight * cropBaseScale * cropScale;

      cropCanvasCtx.fillStyle = '#0f172a';
      cropCanvasCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
      cropCanvasCtx.save();
      cropCanvasCtx.translate(
        cropOffsetX + (cropFlipX === -1 ? renderWidth : 0),
        cropOffsetY + (cropFlipY === -1 ? renderHeight : 0)
      );
      cropCanvasCtx.scale(cropFlipX, cropFlipY);
      cropCanvasCtx.drawImage(cropImage, 0, 0, renderWidth, renderHeight);
      cropCanvasCtx.restore();

      cropCanvasCtx.strokeStyle = 'rgba(255,255,255,0.65)';
      cropCanvasCtx.lineWidth = 1;
      cropCanvasCtx.strokeRect(0.5, 0.5, cropCanvas.width - 1, cropCanvas.height - 1);
    }

    function fitCropImage() {
      if (!cropImage) return;

      setCropCanvasSize();
      const coverScaleX = cropCanvas.width / cropImage.naturalWidth;
      const coverScaleY = cropCanvas.height / cropImage.naturalHeight;
      cropBaseScale = Math.max(coverScaleX, coverScaleY);
      cropScale = 1;

      const renderWidth = cropImage.naturalWidth * cropBaseScale * cropScale;
      const renderHeight = cropImage.naturalHeight * cropBaseScale * cropScale;
      cropOffsetX = (cropCanvas.width - renderWidth) / 2;
      cropOffsetY = (cropCanvas.height - renderHeight) / 2;

      cropZoomInput.min = '1';
      cropZoomInput.max = '5';
      cropZoomInput.step = '0.01';
      syncCropZoomInput();
      clampCropOffsets();
      drawCropCanvas();
    }

    function centerCropImage() {
      if (!cropImage) return;

      const renderWidth = cropImage.naturalWidth * cropBaseScale * cropScale;
      const renderHeight = cropImage.naturalHeight * cropBaseScale * cropScale;
      cropOffsetX = (cropCanvas.width - renderWidth) / 2;
      cropOffsetY = (cropCanvas.height - renderHeight) / 2;

      clampCropOffsets();
      drawCropCanvas();
      clearCropDownload();
    }

    function flipCropHorizontal() {
      if (!cropImage) return;
      cropFlipX *= -1;
      drawCropCanvas();
      updateCropTransformButtons();
      clearCropDownload();
    }

    function flipCropVertical() {
      if (!cropImage) return;
      cropFlipY *= -1;
      drawCropCanvas();
      updateCropTransformButtons();
      clearCropDownload();
    }

    function updateCropTransformButtons() {
      const flipHBtn = document.getElementById('crop-flip-h-btn');
      const flipVBtn = document.getElementById('crop-flip-v-btn');
      if (!flipHBtn || !flipVBtn) return;

      const hActive = cropFlipX === -1;
      const vActive = cropFlipY === -1;

      flipHBtn.classList.toggle('btn-toggle-active', hActive);
      flipVBtn.classList.toggle('btn-toggle-active', vActive);
      flipHBtn.textContent = hActive ? 'Flip H ‚úì' : 'Flip H';
      flipVBtn.textContent = vActive ? 'Flip V ‚úì' : 'Flip V';
      flipHBtn.setAttribute('aria-pressed', hActive ? 'true' : 'false');
      flipVBtn.setAttribute('aria-pressed', vActive ? 'true' : 'false');
    }

    function clearCropDownload() {
      if (cropDownloadUrl) {
        URL.revokeObjectURL(cropDownloadUrl);
        cropDownloadUrl = null;
      }
      document.getElementById('crop-download-link').style.display = 'none';
      document.getElementById('crop-result-info').style.display = 'none';
      document.getElementById('crop-result-info').innerHTML = '';
    }

    function setCropButtonsEnabled(enabled) {
      document.getElementById('crop-apply-size-btn').disabled = !enabled;
      document.getElementById('crop-fit-btn').disabled = !enabled;
      document.getElementById('crop-center-btn').disabled = !enabled;
      document.getElementById('crop-flip-h-btn').disabled = !enabled;
      document.getElementById('crop-flip-v-btn').disabled = !enabled;
      document.getElementById('crop-export-btn').disabled = !enabled;
    }

    function handleCropFiles(files) {
      if (!files || files.length === 0) return;

      const file = files[0];
      if (!file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }

      resetCropper(false);
      cropFile = file;

      if (cropObjectUrl) {
        URL.revokeObjectURL(cropObjectUrl);
      }
      cropObjectUrl = URL.createObjectURL(file);

      const image = new Image();
      image.onload = () => {
        cropImage = image;
        cropEditor.classList.add('active');
        document.getElementById('crop-upload-text').style.display = 'none';
        document.getElementById('crop-file-info').textContent = `Original: ${file.name} (${formatSize(file.size)}) ¬∑ ${cropImage.naturalWidth}√ó${cropImage.naturalHeight}`;
        document.getElementById('crop-error-msg').textContent = '';

        applyCropTargetSize();
        setCropButtonsEnabled(true);
      };

      image.onerror = () => {
        document.getElementById('crop-error-msg').textContent = 'Failed to read image, please try again';
      };

      image.src = cropObjectUrl;
    }

    function applyCropTargetSize() {
      const width = parsePositiveInt(cropTargetWidthInput.value, cropTargetWidth);
      const height = parsePositiveInt(cropTargetHeightInput.value, cropTargetHeight);

      cropTargetWidth = width;
      cropTargetHeight = height;
      cropTargetWidthInput.value = String(width);
      cropTargetHeightInput.value = String(height);
      cropAspectRatio = width / height;

      clearCropDownload();
      if (cropImage) {
        fitCropImage();
      }
    }

    function updateCropSizeByWidth() {
      if (!cropLockRatioInput.checked) {
        cropAspectRatio = parsePositiveInt(cropTargetWidthInput.value, cropTargetWidth) / parsePositiveInt(cropTargetHeightInput.value, cropTargetHeight);
        return;
      }

      const width = parsePositiveInt(cropTargetWidthInput.value, cropTargetWidth);
      const nextHeight = Math.max(1, Math.round(width / cropAspectRatio));
      cropTargetHeightInput.value = String(nextHeight);
    }

    function updateCropSizeByHeight() {
      if (!cropLockRatioInput.checked) {
        cropAspectRatio = parsePositiveInt(cropTargetWidthInput.value, cropTargetWidth) / parsePositiveInt(cropTargetHeightInput.value, cropTargetHeight);
        return;
      }

      const height = parsePositiveInt(cropTargetHeightInput.value, cropTargetHeight);
      const nextWidth = Math.max(1, Math.round(height * cropAspectRatio));
      cropTargetWidthInput.value = String(nextWidth);
    }

    function applyCropPresetRatio(ratioText) {
      const [rw, rh] = ratioText.split(':').map(Number);
      if (!rw || !rh) return;

      cropAspectRatio = rw / rh;
      cropLockRatioInput.checked = true;

      const currentWidth = parsePositiveInt(cropTargetWidthInput.value, cropTargetWidth);
      cropTargetHeightInput.value = String(Math.max(1, Math.round(currentWidth / cropAspectRatio)));
      applyCropTargetSize();
    }

    function setCropScaleFromPoint(nextScale, pivotX, pivotY) {
      if (!cropImage) return;

      const minScale = 1;
      const maxScale = 5;
      const safeScale = Math.min(maxScale, Math.max(minScale, nextScale));
      const oldScale = cropScale;
      if (safeScale === oldScale) return;

      const ratio = safeScale / oldScale;
      cropOffsetX = pivotX - (pivotX - cropOffsetX) * ratio;
      cropOffsetY = pivotY - (pivotY - cropOffsetY) * ratio;
      cropScale = safeScale;

      clampCropOffsets();
      syncCropZoomInput();
      drawCropCanvas();
      clearCropDownload();
    }

    function exportCroppedImage() {
      if (!cropImage || !cropFile) return;

      const exportBtn = document.getElementById('crop-export-btn');
      exportBtn.disabled = true;
      exportBtn.textContent = 'Exporting...';

      document.getElementById('crop-error-msg').textContent = '';

      try {
        const outputCanvas = document.createElement('canvas');
        outputCanvas.width = cropTargetWidth;
        outputCanvas.height = cropTargetHeight;
        const outputCtx = outputCanvas.getContext('2d');

        const scaleX = cropTargetWidth / cropCanvas.width;
        const scaleY = cropTargetHeight / cropCanvas.height;
        const renderWidth = cropImage.naturalWidth * cropBaseScale * cropScale * scaleX;
        const renderHeight = cropImage.naturalHeight * cropBaseScale * cropScale * scaleY;
        const renderX = cropOffsetX * scaleX;
        const renderY = cropOffsetY * scaleY;

        outputCtx.fillStyle = '#ffffff';
        outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
        outputCtx.save();
        outputCtx.translate(
          renderX + (cropFlipX === -1 ? renderWidth : 0),
          renderY + (cropFlipY === -1 ? renderHeight : 0)
        );
        outputCtx.scale(cropFlipX, cropFlipY);
        outputCtx.drawImage(cropImage, 0, 0, renderWidth, renderHeight);
        outputCtx.restore();

        const { type, quality, ext } = getCropOutputConfig();
        outputCanvas.toBlob((blob) => {
          if (!blob) {
            document.getElementById('crop-error-msg').textContent = 'Export failed, please try another output format';
            return;
          }

          clearCropDownload();
          cropDownloadUrl = URL.createObjectURL(blob);

          const baseName = getCropBaseName(cropFile);
          const downloadLink = document.getElementById('crop-download-link');
          downloadLink.href = cropDownloadUrl;
          downloadLink.download = `${baseName}_${cropTargetWidth}x${cropTargetHeight}.${ext}`;
          downloadLink.style.display = 'inline-block';

          const resultInfo = document.getElementById('crop-result-info');
          resultInfo.innerHTML = `
            <div class="info-row">
              <span>Output size:</span>
              <span class="success-text">${cropTargetWidth} √ó ${cropTargetHeight}</span>
            </div>
            <div class="info-row">
              <span>Format:</span>
              <span>${ext.toUpperCase()}</span>
            </div>
            <div class="info-row">
              <span>File size:</span>
              <span>${formatSize(blob.size)}</span>
            </div>
          `;
          resultInfo.style.display = 'block';
        }, type, type === 'image/png' ? undefined : quality);
      } finally {
        exportBtn.disabled = false;
        exportBtn.textContent = 'Export Image';
      }
    }

    function bindCropCanvasEvents() {
      cropCanvas.addEventListener('pointerdown', (event) => {
        if (!cropImage) return;
        cropDragging = true;
        cropDragStartX = event.clientX - cropOffsetX;
        cropDragStartY = event.clientY - cropOffsetY;
        cropCanvas.classList.add('dragging');
        cropCanvas.setPointerCapture(event.pointerId);
      });

      cropCanvas.addEventListener('pointermove', (event) => {
        if (!cropDragging || !cropImage) return;
        cropOffsetX = event.clientX - cropDragStartX;
        cropOffsetY = event.clientY - cropDragStartY;
        clampCropOffsets();
        drawCropCanvas();
        clearCropDownload();
      });

      const releaseDrag = (event) => {
        cropDragging = false;
        cropCanvas.classList.remove('dragging');
        if (event && event.pointerId !== undefined) {
          try { cropCanvas.releasePointerCapture(event.pointerId); } catch (_) {}
        }
      };

      cropCanvas.addEventListener('pointerup', releaseDrag);
      cropCanvas.addEventListener('pointercancel', releaseDrag);
      cropCanvas.addEventListener('pointerleave', () => {
        if (cropDragging) return;
        cropCanvas.classList.remove('dragging');
      });

      cropCanvas.addEventListener('wheel', (event) => {
        if (!cropImage) return;
        event.preventDefault();

        const rect = cropCanvas.getBoundingClientRect();
        const pivotX = event.clientX - rect.left;
        const pivotY = event.clientY - rect.top;
        const factor = event.deltaY < 0 ? 1.06 : 0.94;
        setCropScaleFromPoint(cropScale * factor, pivotX, pivotY);
      }, { passive: false });

      cropCanvas.addEventListener('touchstart', (event) => {
        if (event.touches.length === 2) {
          const dx = event.touches[0].clientX - event.touches[1].clientX;
          const dy = event.touches[0].clientY - event.touches[1].clientY;
          cropLastPinchDistance = Math.hypot(dx, dy);
        }
      }, { passive: true });

      cropCanvas.addEventListener('touchmove', (event) => {
        if (!cropImage || event.touches.length !== 2) return;
        event.preventDefault();

        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        const distance = Math.hypot(dx, dy);
        if (!cropLastPinchDistance) {
          cropLastPinchDistance = distance;
          return;
        }

        const rect = cropCanvas.getBoundingClientRect();
        const pivotX = ((event.touches[0].clientX + event.touches[1].clientX) / 2) - rect.left;
        const pivotY = ((event.touches[0].clientY + event.touches[1].clientY) / 2) - rect.top;

        const pinchFactor = distance / cropLastPinchDistance;
        cropLastPinchDistance = distance;
        setCropScaleFromPoint(cropScale * pinchFactor, pivotX, pivotY);
      }, { passive: false });

      cropCanvas.addEventListener('touchend', () => {
        cropLastPinchDistance = 0;
      }, { passive: true });
    }

    function resetCropper(clearFileInput = true) {
      if (clearFileInput) {
        document.getElementById('crop-input').value = '';
      }

      if (cropObjectUrl) {
        URL.revokeObjectURL(cropObjectUrl);
        cropObjectUrl = null;
      }

      clearCropDownload();

      cropFile = null;
      cropImage = null;
      cropDragging = false;
      cropLastPinchDistance = 0;
      cropBaseScale = 1;
      cropScale = 1;
      cropOffsetX = 0;
      cropOffsetY = 0;
      cropFlipX = 1;
      cropFlipY = 1;
      updateCropTransformButtons();

      cropTargetWidth = 1080;
      cropTargetHeight = 1080;
      cropAspectRatio = 1;
      cropTargetWidthInput.value = '1080';
      cropTargetHeightInput.value = '1080';
      cropLockRatioInput.checked = true;
      document.getElementById('crop-output-format').value = 'image/png';
      document.getElementById('crop-quality').value = '0.92';
      toggleCropQuality();

      cropEditor.classList.remove('active');
      document.getElementById('crop-upload-text').style.display = 'block';
      document.getElementById('crop-file-info').textContent = '';
      document.getElementById('crop-error-msg').textContent = '';

      setCropButtonsEnabled(false);
      setCropCanvasSize();
      drawCropCanvas();
      syncCropZoomInput();
    }

    cropZoomInput.addEventListener('input', () => {
      if (!cropImage) return;
      const rect = cropCanvas.getBoundingClientRect();
      const pivotX = rect.width / 2;
      const pivotY = rect.height / 2;
      setCropScaleFromPoint(parseFloat(cropZoomInput.value), pivotX, pivotY);
    });

    cropTargetWidthInput.addEventListener('input', updateCropSizeByWidth);
    cropTargetHeightInput.addEventListener('input', updateCropSizeByHeight);
    cropTargetWidthInput.addEventListener('change', applyCropTargetSize);
    cropTargetHeightInput.addEventListener('change', applyCropTargetSize);
    cropLockRatioInput.addEventListener('change', () => {
      if (cropLockRatioInput.checked) {
        const width = parsePositiveInt(cropTargetWidthInput.value, cropTargetWidth);
        const height = parsePositiveInt(cropTargetHeightInput.value, cropTargetHeight);
        cropAspectRatio = width / height;
      }
    });

    document.querySelectorAll('#resize-crop .ratio-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => applyCropPresetRatio(btn.dataset.ratio));
    });

    window.addEventListener('resize', () => {
      if (!cropImage) return;
      fitCropImage();
    });

    bindCropCanvasEvents();
    toggleCropQuality();
    resetCropper();

    const bgSourceCanvas = document.getElementById('bg-source-canvas');
    const bgSourceCtx = bgSourceCanvas.getContext('2d');
    const bgResultCanvas = document.getElementById('bg-result-canvas');
    const bgResultCtx = bgResultCanvas.getContext('2d');
    const bgThresholdInput = document.getElementById('bg-threshold');
    const bgThresholdValue = document.getElementById('bg-threshold-value');
    const bgFeatherInput = document.getElementById('bg-feather');
    const bgFeatherValue = document.getElementById('bg-feather-value');
    const bgUseAutoInput = document.getElementById('bg-use-auto');
    const bgColorInput = document.getElementById('bg-color');

    let bgFile = null;
    let bgImage = null;
    let bgObjectUrl = null;
    let bgDownloadUrl = null;
    let bgAutoColor = { r: 255, g: 255, b: 255 };

    function hexToRgb(hex) {
      const clean = (hex || '').replace('#', '');
      if (clean.length !== 6) return { r: 255, g: 255, b: 255 };
      return {
        r: parseInt(clean.slice(0, 2), 16),
        g: parseInt(clean.slice(2, 4), 16),
        b: parseInt(clean.slice(4, 6), 16)
      };
    }

    function rgbToHex(rgb) {
      const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, '0');
      return `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`;
    }

    function clearBgDownload() {
      if (bgDownloadUrl) {
        URL.revokeObjectURL(bgDownloadUrl);
        bgDownloadUrl = null;
      }
      document.getElementById('bg-download-link').style.display = 'none';
      document.getElementById('bg-result-info').style.display = 'none';
      document.getElementById('bg-result-info').innerHTML = '';
    }

    function setBgButtonsEnabled(enabled) {
      document.getElementById('bg-detect-btn').disabled = !enabled;
      document.getElementById('bg-run-btn').disabled = !enabled;
    }

    function sampleAutoBackgroundColor() {
      const width = bgSourceCanvas.width;
      const height = bgSourceCanvas.height;
      if (!width || !height) return { r: 255, g: 255, b: 255 };

      const data = bgSourceCtx.getImageData(0, 0, width, height).data;
      let rSum = 0;
      let gSum = 0;
      let bSum = 0;
      let count = 0;

      const step = Math.max(1, Math.floor(Math.min(width, height) / 80));
      for (let x = 0; x < width; x += step) {
        const topIdx = (0 * width + x) * 4;
        const bottomIdx = ((height - 1) * width + x) * 4;
        rSum += data[topIdx] + data[bottomIdx];
        gSum += data[topIdx + 1] + data[bottomIdx + 1];
        bSum += data[topIdx + 2] + data[bottomIdx + 2];
        count += 2;
      }

      for (let y = 0; y < height; y += step) {
        const leftIdx = (y * width + 0) * 4;
        const rightIdx = (y * width + (width - 1)) * 4;
        rSum += data[leftIdx] + data[rightIdx];
        gSum += data[leftIdx + 1] + data[rightIdx + 1];
        bSum += data[leftIdx + 2] + data[rightIdx + 2];
        count += 2;
      }

      return {
        r: rSum / count,
        g: gSum / count,
        b: bSum / count
      };
    }

    function detectBgColorOnly() {
      if (!bgImage) return;
      bgAutoColor = sampleAutoBackgroundColor();
      bgColorInput.value = rgbToHex(bgAutoColor);
      runBackgroundRemoval();
    }

    function getCurrentBgColor() {
      return bgUseAutoInput.checked ? bgAutoColor : hexToRgb(bgColorInput.value);
    }

    function runBackgroundRemoval() {
      if (!bgImage) return;

      const threshold = parseInt(bgThresholdInput.value, 10);
      const feather = parseInt(bgFeatherInput.value, 10);
      const bgColor = getCurrentBgColor();

      const width = bgSourceCanvas.width;
      const height = bgSourceCanvas.height;

      const src = bgSourceCtx.getImageData(0, 0, width, height);
      const out = bgResultCtx.createImageData(width, height);

      for (let i = 0; i < src.data.length; i += 4) {
        const dr = src.data[i] - bgColor.r;
        const dg = src.data[i + 1] - bgColor.g;
        const db = src.data[i + 2] - bgColor.b;
        const distance = Math.sqrt(dr * dr + dg * dg + db * db);

        let alpha = 255;
        if (distance <= threshold) {
          alpha = 0;
        } else if (distance < threshold + feather) {
          alpha = Math.round(((distance - threshold) / Math.max(1, feather)) * 255);
        }

        out.data[i] = src.data[i];
        out.data[i + 1] = src.data[i + 1];
        out.data[i + 2] = src.data[i + 2];
        out.data[i + 3] = alpha;
      }

      bgResultCtx.putImageData(out, 0, 0);
      bgResultCanvas.style.display = 'inline-block';
      clearBgDownload();

      const outputFormat = document.getElementById('bg-output-format').value;
      bgResultCanvas.toBlob((blob) => {
        if (!blob) {
          document.getElementById('bg-error-msg').textContent = 'Export failed, please try again';
          return;
        }

        clearBgDownload();
        bgDownloadUrl = URL.createObjectURL(blob);
        const base = bgFile ? (bgFile.name.includes('.') ? bgFile.name.slice(0, bgFile.name.lastIndexOf('.')) : bgFile.name) : 'image';
        const ext = outputFormat === 'image/webp' ? 'webp' : 'png';

        const downloadLink = document.getElementById('bg-download-link');
        downloadLink.href = bgDownloadUrl;
        downloadLink.download = `${base}_bg_removed.${ext}`;
        downloadLink.style.display = 'inline-block';

        const resultInfo = document.getElementById('bg-result-info');
        resultInfo.innerHTML = `
          <div class="info-row"><span>Output resolution:</span><span class="success-text">${width} √ó ${height}</span></div>
          <div class="info-row"><span>Format:</span><span>${ext.toUpperCase()}</span></div>
          <div class="info-row"><span>File size:</span><span>${formatSize(blob.size)}</span></div>
        `;
        resultInfo.style.display = 'block';
      }, outputFormat, outputFormat === 'image/webp' ? 0.92 : undefined);
    }

    function handleBgFiles(files) {
      if (!files || files.length === 0) return;

      const file = files[0];
      if (!file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }

      resetBgRemoval(false);
      bgFile = file;

      if (bgObjectUrl) {
        URL.revokeObjectURL(bgObjectUrl);
      }
      bgObjectUrl = URL.createObjectURL(file);

      const image = new Image();
      image.onload = () => {
        bgImage = image;
        bgSourceCanvas.width = image.naturalWidth;
        bgSourceCanvas.height = image.naturalHeight;
        bgResultCanvas.width = image.naturalWidth;
        bgResultCanvas.height = image.naturalHeight;
        bgSourceCtx.drawImage(image, 0, 0);

        document.getElementById('bg-upload-text').style.display = 'none';
        document.getElementById('bg-file-info').textContent = `Original: ${file.name} (${formatSize(file.size)}) ¬∑ ${image.naturalWidth}√ó${image.naturalHeight}`;
        document.getElementById('bg-error-msg').textContent = '';

        setBgButtonsEnabled(true);
        detectBgColorOnly();
      };

      image.onerror = () => {
        document.getElementById('bg-error-msg').textContent = 'Failed to read image, please try again';
      };

      image.src = bgObjectUrl;
    }

    function resetBgRemoval(clearFileInput = true) {
      if (clearFileInput) {
        document.getElementById('bg-input').value = '';
      }
      if (bgObjectUrl) {
        URL.revokeObjectURL(bgObjectUrl);
        bgObjectUrl = null;
      }

      clearBgDownload();

      bgFile = null;
      bgImage = null;
      bgAutoColor = { r: 255, g: 255, b: 255 };

      document.getElementById('bg-upload-text').style.display = 'block';
      document.getElementById('bg-file-info').textContent = '';
      document.getElementById('bg-error-msg').textContent = '';
      bgResultCanvas.style.display = 'none';
      bgSourceCtx.clearRect(0, 0, bgSourceCanvas.width, bgSourceCanvas.height);
      bgResultCtx.clearRect(0, 0, bgResultCanvas.width, bgResultCanvas.height);

      bgThresholdInput.value = '45';
      bgFeatherInput.value = '30';
      bgThresholdValue.textContent = '45';
      bgFeatherValue.textContent = '30';
      bgUseAutoInput.checked = true;
      bgColorInput.value = '#ffffff';
      document.getElementById('bg-output-format').value = 'image/png';

      setBgButtonsEnabled(false);
    }

    bgThresholdInput.addEventListener('input', () => {
      bgThresholdValue.textContent = bgThresholdInput.value;
      if (bgImage) runBackgroundRemoval();
    });

    bgFeatherInput.addEventListener('input', () => {
      bgFeatherValue.textContent = bgFeatherInput.value;
      if (bgImage) runBackgroundRemoval();
    });

    bgUseAutoInput.addEventListener('change', () => {
      if (bgImage) runBackgroundRemoval();
    });

    bgColorInput.addEventListener('input', () => {
      if (bgImage && !bgUseAutoInput.checked) runBackgroundRemoval();
    });

    document.getElementById('bg-output-format').addEventListener('change', () => {
      if (bgImage) runBackgroundRemoval();
    });

    resetBgRemoval();

    window.addEventListener('beforeunload', clearGridResults);

    // ==================== Video to GIF Logic ====================
    let videoFile = null;
    const videoPreview = document.getElementById('preview-video');

    function handleVideoFiles(files) {
      if (files.length === 0) return;

      const file = files[0];
      if (!file.type.startsWith('video/')) {
        alert('Please select a valid video file');
        return;
      }

      videoFile = file;
      document.getElementById('video-file-info').textContent = `Filename: ${file.name} (${formatSize(file.size)})`;
      document.getElementById('video-upload-text').style.display = 'none';
      document.getElementById('video-preview-container').style.display = 'block';

      const url = URL.createObjectURL(file);
      videoPreview.src = url;

      videoPreview.onloadedmetadata = () => {
        document.getElementById('gif-duration').value = Math.min(3, videoPreview.duration).toFixed(1);
        document.getElementById('gif-start').max = videoPreview.duration;
        document.getElementById('generate-gif-btn').disabled = false;
      };

      document.getElementById('gif-result-container').style.display = 'none';
      document.getElementById('gif-download-link').style.display = 'none';
      document.getElementById('gif-progress-container').style.display = 'none';
    }

    async function generateGif() {
      if (!videoFile) return;

      const start = parseFloat(document.getElementById('gif-start').value);
      const duration = parseFloat(document.getElementById('gif-duration').value);
      const width = parseInt(document.getElementById('gif-width').value);
      const fps = parseInt(document.getElementById('gif-fps').value);
      const quality = parseInt(document.getElementById('gif-quality').value);
      const text = document.getElementById('gif-text').value;

      const btn = document.getElementById('generate-gif-btn');
      btn.disabled = true;
      btn.textContent = 'Generating...';

      document.getElementById('gif-progress-container').style.display = 'block';
      updateProgress(0, 'Processing frames...');

      try {
        const GIFRuntime = await loadGifLib();

        // Load worker blob
        const workerBlob = await fetch(GIF_WORKER_URL)
          .then(r => r.blob());
        const workerUrl = URL.createObjectURL(workerBlob);

        const gif = new GIFRuntime({
          workers: 2,
          quality: quality,
          width: width,
          height: width * (videoPreview.videoHeight / videoPreview.videoWidth),
          workerScript: workerUrl
        });

        // Frame extraction
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = width;
        canvas.height = width * (videoPreview.videoHeight / videoPreview.videoWidth);

        const step = 1 / fps;
        let currentTime = start;
        const endTime = Math.min(start + duration, videoPreview.duration);

        // Temp video element
        const tempVideo = document.createElement('video');
        tempVideo.src = videoPreview.src;
        tempVideo.muted = true;

        await new Promise(r => {
           tempVideo.onloadedmetadata = r;
        });

        const frameCount = Math.ceil((endTime - start) * fps);
        let processedFrames = 0;

        const seekAndCapture = async () => {
          if (currentTime >= endTime) {
            updateProgress(50, 'Rendering GIF...');
            gif.render();
            return;
          }

          tempVideo.currentTime = currentTime;
          await new Promise(r => {
             tempVideo.onseeked = r;
          });

          ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);

          // Add text
          if (text) {
            ctx.font = `${canvas.width / 15}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(text, canvas.width / 2, canvas.height - 10);
            ctx.fillText(text, canvas.width / 2, canvas.height - 10);
          }

          gif.addFrame(ctx, {copy: true, delay: 1000 / fps});

          processedFrames++;
          updateProgress(Math.floor((processedFrames / frameCount) * 50), `Capturing frame ${processedFrames}/${frameCount}`);

          currentTime += step;
          setTimeout(seekAndCapture, 0); // avoid blocking main thread
        };

        gif.on('progress', (p) => {
          updateProgress(50 + Math.floor(p * 50), 'Encoding GIF...');
        });

        gif.on('finished', (blob) => {
          const url = URL.createObjectURL(blob);
          const img = document.getElementById('generated-gif');
          img.src = url;
          img.style.display = 'block';

          document.getElementById('gif-result-container').style.display = 'block';

          const downloadLink = document.getElementById('gif-download-link');
          downloadLink.href = url;
          downloadLink.download = `video_${Date.now()}.gif`;
          downloadLink.style.display = 'inline-block';

          btn.disabled = false;
          btn.textContent = 'Generate GIF';
          updateProgress(100, 'Done!');
          URL.revokeObjectURL(workerUrl); // cleanup
        });

        seekAndCapture();

      } catch (e) {
        console.error(e);
        alert('Generation failed: ' + e.message);
        btn.disabled = false;
        btn.textContent = 'Generate GIF';
      }
    }

    function updateProgress(percent, status) {
      document.getElementById('gif-progress-bar').style.width = `${percent}%`;
      document.getElementById('gif-progress-text').textContent = `${percent}%`;
      document.getElementById('gif-status-text').textContent = status;
    }

    function resetVideo() {
      document.getElementById('video-input').value = '';
      document.getElementById('video-upload-text').style.display = 'block';
      document.getElementById('video-preview-container').style.display = 'none';
      document.getElementById('generate-gif-btn').disabled = true;
      document.getElementById('gif-result-container').style.display = 'none';
      document.getElementById('gif-download-link').style.display = 'none';
      document.getElementById('gif-progress-container').style.display = 'none';
      videoFile = null;
    }

    // ==================== Video Compression Logic ====================
    let vcFile = null;
    let createFFmpeg = null;
    let fetchFile = null;
    let ffmpeg = null;

    function toggleVcResolution() {
      const res = document.getElementById('vc-resolution').value;
      document.getElementById('vc-custom-res').style.display = res === 'custom' ? 'flex' : 'none';
    }

    function toggleVcMode() {
      const mode = document.getElementById('vc-mode').value;
      document.getElementById('vc-crf-group').style.display = mode === 'crf' ? 'flex' : 'none';
      document.getElementById('vc-bitrate-group').style.display = mode === 'bitrate' ? 'flex' : 'none';
    }

    // Drop Zone
    const vcDropZone = document.getElementById('vc-drop-zone');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      vcDropZone.addEventListener(eventName, preventDefaults, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
      vcDropZone.addEventListener(eventName, () => vcDropZone.classList.add('drag-over'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
      vcDropZone.addEventListener(eventName, () => vcDropZone.classList.remove('drag-over'), false);
    });
    vcDropZone.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      handleVcFiles(dt.files);
    }, false);

    function handleVcSelect(e) {
      handleVcFiles(e.target.files);
    }

    function handleVcFiles(files) {
      if (files.length === 0) return;
      const file = files[0];
      if (!file.type.startsWith('video/')) {
        alert('Please select a valid video file');
        return;
      }
      vcFile = file;

      // Preview
      const url = URL.createObjectURL(file);
      const video = document.getElementById('vc-preview-video');
      video.src = url;

      video.onloadedmetadata = () => {
         document.getElementById('vc-file-info').textContent = `Filename: ${file.name}`;
         document.getElementById('vc-file-meta').textContent = `Size: ${formatSize(file.size)} | Res: ${video.videoWidth}x${video.videoHeight} | Duration: ${formatTime(video.duration)}`;
         document.getElementById('vc-start-btn').disabled = false;
         document.getElementById('vc-test-btn').disabled = false;
      };

      document.getElementById('vc-upload-text').style.display = 'none';
      document.getElementById('vc-preview-container').style.display = 'block';
      document.getElementById('vc-result-info').style.display = 'none';
      document.getElementById('vc-download-link').style.display = 'none';
      document.getElementById('vc-error-msg').textContent = '';
      document.getElementById('vc-progress-container').style.display = 'none';
    }

    async function startVideoCompression(isTest) {
      if (!vcFile) return;

      const btn = document.getElementById(isTest ? 'vc-test-btn' : 'vc-start-btn');
      const otherBtn = document.getElementById(isTest ? 'vc-start-btn' : 'vc-test-btn');
      const originalText = btn.textContent;

      btn.disabled = true;
      otherBtn.disabled = true;
      btn.textContent = 'Processing...';

      document.getElementById('vc-progress-container').style.display = 'block';
      document.getElementById('vc-error-msg').textContent = '';
      document.getElementById('vc-result-info').style.display = 'none';
      document.getElementById('vc-download-link').style.display = 'none';

      try {
        if (!createFFmpeg || !fetchFile) {
          updateVcStatus('Loading FFmpeg runtime...', 0);
          const ffmpegLib = await loadFfmpegLib();
          createFFmpeg = ffmpegLib.createFFmpeg;
          fetchFile = ffmpegLib.fetchFile;
        }

        if (!ffmpeg) {
          updateVcStatus('Loading FFmpeg core...', 0);
          ffmpeg = createFFmpeg({
            log: true,
            corePath: FFMPEG_CORE_URL,
            mainName: 'main'
          });

          ffmpeg.setLogger(({ type, message }) => {
            document.getElementById('vc-log-text').textContent = message;
            if (message.includes('time=')) {
               const timeMatch = message.match(/time=(\d{2}):(\d{2}):(\d{2}.\d{2})/);
               if (timeMatch) {
                 const [_, h, m, s] = timeMatch;
                 const currentTime = parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);
                 const totalDuration = isTest ? 5 : document.getElementById('vc-preview-video').duration;
                 const percent = Math.min(99, Math.round((currentTime / totalDuration) * 100));
                 updateVcStatus('Compressing...', percent);
               }
            }
          });

          await ffmpeg.load();
        }

        updateVcStatus('Writing file...', 0);
        const inputName = 'input_' + Date.now() + '.mp4';
        ffmpeg.FS('writeFile', inputName, await fetchFile(vcFile));

        const format = document.getElementById('vc-format').value;
        const outputName = 'output.' + format;

        // Args
        let args = ['-i', inputName];

        // Resolution
        const res = document.getElementById('vc-resolution').value;
        if (res !== 'original') {
           args.push('-vf');
           if (res === 'custom') {
              const w = document.getElementById('vc-width').value || -2;
              const h = document.getElementById('vc-height').value || -2;
              args.push(`scale=${w}:${h}`);
           } else if (res === '1080p') {
              args.push('scale=-2:1080');
           } else if (res === '720p') {
              args.push('scale=-2:720');
           } else if (res === '480p') {
              args.push('scale=-2:480');
           }
        }

        // Test mode
        if (isTest) {
          args.push('-t', '5');
        }

        // Mode
        const mode = document.getElementById('vc-mode').value;
        if (mode === 'crf') {
           const crf = document.getElementById('vc-crf').value;
           if (format === 'webm') {
             args.push('-c:v', 'libvpx-vp9', '-crf', crf, '-b:v', '0');
           } else {
             args.push('-c:v', 'libx264', '-crf', crf, '-preset', 'fast');
           }
        } else {
           const bitrate = document.getElementById('vc-bitrate').value + 'k';
           args.push('-b:v', bitrate);
        }

        if (format === 'webm') {
           // VP9 handled above
        } else {
           args.push('-c:a', 'aac', '-b:a', '128k');
           args.push('-movflags', '+faststart');
        }

        args.push(outputName);

        updateVcStatus('Converting...', 0);
        await ffmpeg.run(...args);

        updateVcStatus('Reading result...', 100);
        const data = ffmpeg.FS('readFile', outputName);

        const blob = new Blob([data.buffer], { type: 'video/' + format });
        const url = URL.createObjectURL(blob);

        const downloadLink = document.getElementById('vc-download-link');
        downloadLink.href = url;
        downloadLink.download = `compressed_${Date.now()}.${format}`;
        downloadLink.style.display = 'inline-block';

        const resultInfo = document.getElementById('vc-result-info');
        const ratio = ((1 - (blob.size / (isTest ? blob.size : vcFile.size))) * 100).toFixed(1);

        let ratioText = '';
        if (!isTest) {
           ratioText = `
            <div class="info-row">
              <span>Original Size:</span>
              <span>${formatSize(vcFile.size)}</span>
            </div>
            <div class="info-row">
              <span>Compressed Size:</span>
              <span class="success-text">${formatSize(blob.size)}</span>
            </div>
            <div class="info-row">
              <span>Ratio:</span>
              <span>-${ratio}%</span>
            </div>`;
        } else {
            ratioText = `<div class="info-row"><span>Test finished, size:</span><span>${formatSize(blob.size)}</span></div>`;
        }

        resultInfo.innerHTML = ratioText;
        resultInfo.style.display = 'block';

        ffmpeg.FS('unlink', inputName);
        ffmpeg.FS('unlink', outputName);

      } catch (e) {
        console.error(e);
        document.getElementById('vc-error-msg').textContent = 'Error: ' + e.message + ' (Ensure browser supports SharedArrayBuffer)';
      } finally {
        btn.disabled = false;
        otherBtn.disabled = false;
        btn.textContent = originalText;
      }
    }

    function updateVcStatus(text, percent) {
      document.getElementById('vc-status-text').textContent = text;
      document.getElementById('vc-progress-text').textContent = percent + '%';
      document.getElementById('vc-progress-bar').style.width = percent + '%';
    }

    function resetVc() {
      document.getElementById('vc-input').value = '';
      document.getElementById('vc-upload-text').style.display = 'block';
      document.getElementById('vc-preview-container').style.display = 'none';
      document.getElementById('vc-start-btn').disabled = true;
      document.getElementById('vc-test-btn').disabled = true;
      document.getElementById('vc-result-info').style.display = 'none';
      document.getElementById('vc-download-link').style.display = 'none';
      document.getElementById('vc-progress-container').style.display = 'none';
      document.getElementById('vc-error-msg').textContent = '';
      vcFile = null;
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }
  </script>
</body>
</html>
