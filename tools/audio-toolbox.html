<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="éŸ³é¢‘å·¥å…·ç®± - åœ¨çº¿éŸ³é¢‘å¤„ç†å·¥å…·é›†åˆï¼ŒåŒ…å«éŸ³é¢‘åˆå¹¶ç­‰å®ç”¨å·¥å…·ã€‚">
  <meta name="keywords" content="éŸ³é¢‘å·¥å…·,éŸ³é¢‘åˆå¹¶,MP3åˆå¹¶,åœ¨çº¿å·¥å…·,éŸ³é¢‘å‰ªè¾‘">
  <title>éŸ³é¢‘å·¥å…·ç®± - é‚“å®‰è‰¯</title>

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸµ</text></svg>">

  <!-- Stylesheets -->
  <link rel="stylesheet" href="/assets/css/themes.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/components.css">
  <link rel="stylesheet" href="/assets/css/utilities.css">

  <!-- Canonical -->
  <link rel="canonical" href="https://denganliang.com/tools/audio-toolbox.html">
  <!-- Alternate language -->
  <link rel="alternate" hreflang="zh" href="/tools/audio-toolbox.html">
  <link rel="alternate" hreflang="en" href="/en/tools/audio-toolbox.html">
  <link rel="alternate" hreflang="x-default" href="/tools/audio-toolbox.html">

  <style>
    .toolbox-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    .toolbox-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .toolbox-header h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }

    .toolbox-header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }

    /* Tabå¯¼èˆª */
    .tab-nav {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid var(--border-color);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tab-btn {
      background: transparent;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      color: var(--text-secondary);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      white-space: nowrap;
      transition: all 0.3s ease;
    }

    .tab-btn:hover {
      color: var(--text-primary);
    }

    .tab-btn.active {
      color: var(--accent-color);
      border-bottom-color: var(--accent-color);
    }

    /* å·¥å…·é¢æ¿ */
    .tool-panel {
      display: none;
    }

    .tool-panel.active {
      display: block;
    }

    /* å·¥å…·å¡ç‰‡ */
    .tool-item {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      margin-bottom: 1.5rem;
    }

    .tool-item h3 {
      margin-bottom: 1rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tool-item h3 .icon {
      font-size: 1.3rem;
    }

    /* æŒ‰é’®ç»„ */
    .btn-group {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .btn {
      background: var(--accent-color);
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      text-align: center;
    }

    .btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    /* æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ */
    .file-upload {
      border: 2px dashed var(--border-color);
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 1.5rem;
    }

    .file-upload:hover, .file-upload.drag-over {
      border-color: var(--accent-color);
      background: var(--bg-secondary);
    }

    .file-upload input[type="file"] {
      display: none;
    }

    /* æ–‡ä»¶åˆ—è¡¨ */
    .file-list {
      margin-top: 1rem;
      text-align: left;
    }

    .file-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      background: var(--bg-secondary);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      transition: transform 0.2s, box-shadow 0.2s;
      border: 1px solid transparent;
    }

    .file-list-item.dragging {
      opacity: 0.5;
      background: var(--bg-primary);
      border: 1px dashed var(--accent-color);
    }

    .file-info-group {
      display: flex;
      align-items: center;
      flex: 1;
      overflow: hidden;
      gap: 0.5rem;
    }

    .drag-handle {
      cursor: grab;
      color: var(--text-secondary);
      padding: 0 0.5rem;
      font-size: 1.2rem;
    }

    .file-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: 500;
    }

    .file-meta {
      color: var(--text-secondary);
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .action-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .icon-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .icon-btn:hover {
      color: var(--text-primary);
      background: rgba(0,0,0,0.05);
    }

    .icon-btn.play-btn {
      color: var(--accent-color);
    }

    .icon-btn.remove-btn {
      color: #ef4444;
    }

    /* æ’­æ”¾å™¨åŒºåŸŸ */
    .audio-player-container {
      margin-top: 1.5rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      display: none;
    }

    .audio-player-container h4 {
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    audio {
      width: 100%;
      outline: none;
    }

    /* è¿›åº¦æ¡ */
    .progress-container {
      margin-top: 1rem;
      display: none;
    }

    .progress-bar-bg {
      height: 10px;
      background: var(--bg-secondary);
      border-radius: 5px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: var(--accent-color);
      transition: width 0.3s;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .success-text {
      color: #10b981;
    }

    .error {
      color: #ef4444;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    .compressor-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .field-group label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .field-group select {
      padding: 0.55rem 0.6rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 0.95rem;
    }

    .field-group select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .metric-grid {
      margin-top: 1rem;
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .metric-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.75rem;
    }

    .metric-label {
      color: var(--text-secondary);
      font-size: 0.8rem;
      margin-bottom: 0.25rem;
    }

    .metric-value {
      color: var(--text-primary);
      font-size: 1rem;
      font-weight: 600;
    }

    .trim-grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      margin-top: 1rem;
    }

    .trim-time-chip {
      display: inline-block;
      font-family: monospace;
      font-size: 0.9rem;
      padding: 0.25rem 0.5rem;
      border-radius: 6px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      margin-left: 0.5rem;
    }

    .trim-points-wrap {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
    }

    .trim-point-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .trim-point-tag {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      padding: 0.25rem 0.6rem;
      font-size: 0.85rem;
      border: 1px solid var(--border-color);
      background: var(--bg-primary);
      font-family: monospace;
    }

    .trim-point-tag button {
      border: none;
      background: transparent;
      color: #ef4444;
      cursor: pointer;
      font-size: 0.85rem;
      line-height: 1;
      padding: 0;
    }

    .trim-segments {
      margin-top: 1rem;
      display: grid;
      gap: 0.75rem;
    }

    .trim-segment-item {
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 0.75rem;
    }

    .trim-segment-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .trim-empty {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    /* å“åº”å¼ */
    @media (max-width: 768px) {
      .toolbox-header h1 {
        font-size: 2rem;
      }

      .tab-nav {
        justify-content: flex-start;
      }

      .tool-item {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- å¯¼èˆªæ  -->
  <nav class="navbar">
    <div class="navbar-content">
      <a href="/" class="navbar-logo">é‚“å®‰è‰¯</a>

      <ul class="navbar-menu">
        <li><a href="/">é¦–é¡µ</a></li>
        <li><a href="/about/">å…³äºæˆ‘</a></li>
        <li><a href="/projects/">é¡¹ç›®</a></li>
        <li><a href="/tools/">å·¥å…·</a></li>
        <li><a href="/blog/">åšå®¢</a></li>
      </ul>

      <div class="navbar-actions">
        <button class="lang-toggle" aria-label="åˆ‡æ¢è¯­è¨€">English</button>
        <button class="theme-toggle" aria-label="åˆ‡æ¢ä¸»é¢˜"></button>
      </div>
    </div>
  </nav>

  <!-- ä¸»è¦å†…å®¹ -->
  <main class="main-content">
    <div class="toolbox-container">
      <!-- é¡µé¢æ ‡é¢˜ -->
      <div class="toolbox-header">
        <h1>ğŸµ éŸ³é¢‘å·¥å…·ç®±</h1>
        <p>é›†æˆéŸ³é¢‘åˆå¹¶ã€æ ¼å¼è½¬æ¢ç­‰å®ç”¨å·¥å…·ï¼Œçº¯å‰ç«¯å¤„ç†ï¼Œä¿æŠ¤éšç§</p>
      </div>

      <!-- Tabå¯¼èˆª -->
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="merge-tools" onclick="switchTab('merge-tools')">éŸ³é¢‘åˆå¹¶</button>
        <button class="tab-btn" data-tab="compress-tools" onclick="switchTab('compress-tools')">éŸ³é¢‘å‹ç¼©</button>
        <button class="tab-btn" data-tab="trim-tools" onclick="switchTab('trim-tools')">æ‰“ç‚¹å‰ªè¾‘</button>
        <button class="tab-btn" data-tab="tts-tools" onclick="switchTab('tts-tools')">SRTè½¬è¯­éŸ³</button>
      </div>

      <!-- åˆå¹¶å·¥å…·é¢æ¿ -->
      <div class="tool-panel active" id="merge-tools">
        <div class="tool-item">
          <h3><span class="icon">ğŸ”—</span> éŸ³é¢‘åˆå¹¶å·¥å…·</h3>

          <div class="file-upload" id="drop-zone" onclick="document.getElementById('file-input').click()">
            <input type="file" id="file-input" accept="audio/*" multiple onchange="handleFileSelect(event)">
            <div id="upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶</p>
              <p class="hint">æ”¯æŒ MP3, WAV, OGG, AAC ç­‰å¸¸è§æ ¼å¼ (æ”¯æŒå¤šé€‰)</p>
            </div>

            <div id="file-list-container" class="file-list" style="display: none;">
              <!-- æ–‡ä»¶åˆ—è¡¨å°†åœ¨è¿™é‡Œç”Ÿæˆ -->
            </div>

            <!-- Hidden audio element for preview logic -->
            <audio id="preview-player" style="display:none;"></audio>
          </div>

          <div class="btn-group">
            <button class="btn" id="merge-btn" onclick="startMerge()" disabled>å¼€å§‹åˆå¹¶</button>
            <button class="btn btn-secondary" onclick="resetMerger()">é‡ç½®</button>
            <a id="download-link" class="btn" style="display: none; background: #10b981;" download>ä¸‹è½½éŸ³é¢‘</a>
          </div>

          <div id="result-player-container" class="audio-player-container">
            <h4>åˆå¹¶ç»“æœé¢„è§ˆ</h4>
            <audio id="result-player" controls></audio>
          </div>

          <div id="progress-container" class="progress-container">
            <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between;">
              <span id="status-text">åˆå§‹åŒ–å¼•æ“...</span>
              <span id="progress-text">0%</span>
            </div>
            <div class="progress-bar-bg">
              <div id="progress-bar" class="progress-bar"></div>
            </div>
            <p id="log-text" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem; font-family: monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></p>
          </div>

          <div id="error-msg" class="error"></div>
        </div>
      </div>

      <div class="tool-panel" id="compress-tools">
        <div class="tool-item">
          <h3><span class="icon">ğŸ—œï¸</span> éŸ³é¢‘å‹ç¼©å·¥å…·</h3>

          <div class="file-upload" id="compress-drop-zone" onclick="document.getElementById('compress-file-input').click()">
            <input type="file" id="compress-file-input" accept=".wav,.mp3,.ogg,.m4a,.aac,.flac,audio/*" onchange="handleCompressFileSelect(event)">
            <div id="compress-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">ç‚¹å‡»æˆ–æ‹–æ‹½éŸ³é¢‘æ–‡ä»¶åˆ°è¿™é‡Œ</p>
              <p class="hint">æ”¯æŒè¾“å…¥ï¼šwav / mp3 / ogg / m4a / aac / flacï¼ˆå°½é‡å¤šï¼‰</p>
            </div>
            <div id="compress-file-info" class="file-list" style="display:none;"></div>
          </div>

          <div class="compressor-options">
            <div class="field-group">
              <label for="compress-output-format">è¾“å‡ºæ ¼å¼</label>
              <select id="compress-output-format" onchange="onCompressFormatChange()">
                <option value="mp3">mp3ï¼ˆé€šç”¨å…¼å®¹ï¼Œæ¨èï¼‰</option>
                <option value="ogg">oggï¼ˆåŒç ç‡éŸ³è´¨æ›´ä¼˜ï¼‰</option>
                <option value="aac">aacï¼ˆç§»åŠ¨ç«¯å¸¸è§ï¼‰</option>
                <option value="wav">wavï¼ˆæ— æŸï¼Œä½“ç§¯æœ€å¤§ï¼‰</option>
              </select>
            </div>
            <div class="field-group">
              <label for="compress-bitrate">æ¯”ç‰¹ç‡ï¼ˆkbpsï¼‰</label>
              <select id="compress-bitrate">
                <option value="32">32 kbpsï¼ˆè¯­éŸ³ï¼Œæä½ï¼‰</option>
                <option value="48">48 kbpsï¼ˆè¯­éŸ³ / æé™å‹ç¼©ï¼‰</option>
                <option value="64">64 kbpsï¼ˆå°æ¸¸æˆBGMï¼Œç§»åŠ¨ç«¯ï¼‰</option>
                <option value="96">96 kbpsï¼ˆä¸€èˆ¬éŸ³ä¹ï¼Œå¯æ¥å—ï¼‰</option>
                <option value="128" selected>128 kbpsï¼ˆæ ‡å‡†è´¨é‡ï¼Œé»˜è®¤ï¼‰</option>
                <option value="160">160 kbpsï¼ˆè¾ƒé«˜è´¨é‡ï¼ŒPCæ¸¸æˆï¼‰</option>
                <option value="192">192 kbpsï¼ˆé«˜è´¨é‡ï¼ŒéŸ³ä¹ç±»ï¼‰</option>
                <option value="256">256 kbpsï¼ˆæ¥è¿‘æ— æŸï¼Œæ–‡ä»¶è¾ƒå¤§ï¼‰</option>
                <option value="320">320 kbpsï¼ˆMP3æœ€é«˜ï¼Œä½“ç§¯æœ€å¤§ï¼‰</option>
              </select>
            </div>
            <div class="field-group">
              <label for="compress-channels">å£°é“</label>
              <select id="compress-channels">
                <option value="keep" selected>keepï¼ˆä¿æŒåŸå£°é“ï¼Œæ¨èï¼‰</option>
                <option value="mono">monoï¼ˆ1 å£°é“ï¼Œè¯­éŸ³ / çœä½“ç§¯ï¼‰</option>
                <option value="stereo">stereoï¼ˆ2 å£°é“ï¼ŒéŸ³ä¹æ¨èï¼‰</option>
              </select>
            </div>
            <div class="field-group">
              <label for="compress-sample-rate">é‡‡æ ·ç‡ï¼ˆHzï¼‰</label>
              <select id="compress-sample-rate">
                <option value="keep" selected>keepï¼ˆä¿æŒåŸé‡‡æ ·ç‡ï¼Œæ¨èï¼‰</option>
                <option value="8000">8000 Hzï¼ˆç”µè¯è¯­éŸ³ï¼‰</option>
                <option value="11025">11025 Hzï¼ˆè€è®¾å¤‡å…¼å®¹ï¼‰</option>
                <option value="16000">16000 Hzï¼ˆè¯­éŸ³è¯†åˆ«ï¼‰</option>
                <option value="22050">22050 Hzï¼ˆç§»åŠ¨ç«¯ BGM æ¨èï¼‰</option>
                <option value="32000">32000 Hzï¼ˆè¿‡æ¸¡æ¡£ï¼‰</option>
                <option value="44100">44100 Hzï¼ˆCD æ ‡å‡†ï¼Œæœ€å¸¸ç”¨ï¼‰</option>
                <option value="48000">48000 Hzï¼ˆè§†é¢‘ / æ¸¸æˆå¸¸ç”¨ï¼‰</option>
                <option value="96000">96000 Hzï¼ˆä¸“ä¸šéŸ³é¢‘ï¼Œä¸å»ºè®®å‹ç¼©ï¼‰</option>
              </select>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn" id="compress-start-btn" onclick="startCompress()" disabled>å¼€å§‹å‹ç¼©</button>
            <button class="btn btn-secondary" id="compress-cancel-btn" onclick="cancelCompress()" disabled>å–æ¶ˆ</button>
            <button class="btn btn-secondary" onclick="resetCompressor()">é‡ç½®</button>
            <a id="compress-download-link" class="btn" style="display:none; background:#10b981;" download>ä¸‹è½½éŸ³é¢‘</a>
          </div>

          <div id="compress-progress-container" class="progress-container">
            <div style="margin-bottom: 0.5rem; display:flex; justify-content:space-between;">
              <span id="compress-status-text">ç­‰å¾…æ–‡ä»¶</span>
              <span id="compress-progress-text">0%</span>
            </div>
            <div class="progress-bar-bg">
              <div id="compress-progress-bar" class="progress-bar"></div>
            </div>
            <p id="compress-log-text" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem; font-family: monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></p>
          </div>

          <div class="metric-grid">
            <div class="metric-card">
              <div class="metric-label">è¾“å…¥å¤§å°</div>
              <div class="metric-value" id="compress-input-size">-</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">è¾“å‡ºå¤§å°</div>
              <div class="metric-value" id="compress-output-size">-</div>
            </div>
            <div class="metric-card">
              <div class="metric-label">å‹ç¼©æ¯”ä¾‹</div>
              <div class="metric-value" id="compress-ratio">-</div>
            </div>
          </div>

          <div id="compress-result-container" class="audio-player-container">
            <h4>å‹ç¼©ç»“æœè¯•å¬</h4>
            <audio id="compress-result-player" controls></audio>
          </div>

          <div id="compress-error-msg" class="error"></div>
        </div>
      </div>

      <div class="tool-panel" id="trim-tools">
        <div class="tool-item">
          <h3><span class="icon">ğŸ¯</span> éŸ³é¢‘æ‰“ç‚¹å‰ªè¾‘ï¼ˆè£å‰ª / åˆ†å‰²ï¼‰</h3>

          <div class="file-upload" id="trim-drop-zone" onclick="document.getElementById('trim-file-input').click()">
            <input type="file" id="trim-file-input" accept="audio/*" onchange="handleTrimFileSelect(event)">
            <div id="trim-upload-text">
              <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ éŸ³é¢‘</p>
              <p class="hint">æ”¯æŒæ‰“ç‚¹åˆ†å‰²ä¸åŒºé—´è£å‰ªï¼Œå…¨éƒ¨æµè§ˆå™¨æœ¬åœ°å¤„ç†</p>
            </div>
            <div id="trim-file-info" class="file-list" style="display:none;"></div>
          </div>

          <div id="trim-player-wrap" class="audio-player-container" style="display:none;">
            <h4>æ‰“ç‚¹æ’­æ”¾å™¨ <span class="trim-time-chip" id="trim-current-time">00:00.00</span></h4>
            <audio id="trim-player" controls></audio>
          </div>

          <div class="trim-grid">
            <div class="field-group">
              <label for="trim-start">å¼€å§‹æ—¶é—´ï¼ˆç§’ï¼‰</label>
              <input id="trim-start" type="number" min="0" step="0.01" style="padding:0.55rem 0.6rem; border:1px solid var(--border-color); border-radius:6px; background:var(--bg-primary); color:var(--text-primary);">
            </div>
            <div class="field-group">
              <label for="trim-end">ç»“æŸæ—¶é—´ï¼ˆç§’ï¼‰</label>
              <input id="trim-end" type="number" min="0" step="0.01" style="padding:0.55rem 0.6rem; border:1px solid var(--border-color); border-radius:6px; background:var(--bg-primary); color:var(--text-primary);">
            </div>
            <div class="field-group">
              <label for="trim-output-format">å¯¼å‡ºæ ¼å¼</label>
              <select id="trim-output-format" onchange="onTrimFormatChange()">
                <option value="mp3">mp3</option>
                <option value="ogg">ogg</option>
                <option value="aac">aac</option>
                <option value="wav">wav</option>
              </select>
            </div>
            <div class="field-group">
              <label for="trim-bitrate">æ¯”ç‰¹ç‡</label>
              <select id="trim-bitrate">
                <option value="64">64k</option>
                <option value="96">96k</option>
                <option value="128" selected>128k</option>
                <option value="192">192k</option>
              </select>
            </div>
          </div>

          <div class="btn-group">
            <button class="btn btn-secondary" id="trim-set-start-btn" onclick="setTrimBoundary('start')" disabled>è®¾ä¸ºå¼€å§‹ç‚¹</button>
            <button class="btn btn-secondary" id="trim-set-end-btn" onclick="setTrimBoundary('end')" disabled>è®¾ä¸ºç»“æŸç‚¹</button>
            <button class="btn" id="trim-cut-btn" onclick="cutTrimRange()" disabled>è£å‰ªå½“å‰åŒºé—´</button>
          </div>

          <div class="trim-points-wrap">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:0.5rem;">
              <strong style="font-size:0.95rem;">åˆ†å‰²æ‰“ç‚¹ï¼ˆæŒ‰æ—¶é—´åˆ‡æ®µï¼‰</strong>
              <span class="hint" id="trim-duration-text">æ€»æ—¶é•¿ï¼š-</span>
            </div>
            <div class="btn-group" style="margin-top:0.5rem;">
              <button class="btn" id="trim-add-point-btn" onclick="addTrimPoint()" disabled>æ·»åŠ æ‰“ç‚¹</button>
              <button class="btn btn-secondary" id="trim-split-btn" onclick="splitByTrimPoints()" disabled>æŒ‰æ‰“ç‚¹åˆ†å‰²</button>
              <button class="btn btn-secondary" id="trim-clear-points-btn" onclick="clearTrimPoints()" disabled>æ¸…ç©ºæ‰“ç‚¹</button>
            </div>
            <div id="trim-point-list" class="trim-point-list"></div>
            <p id="trim-point-empty" class="trim-empty">è¿˜æ²¡æœ‰æ‰“ç‚¹ï¼Œæ’­æ”¾åˆ°ç›®æ ‡æ—¶é—´åç‚¹â€œæ·»åŠ æ‰“ç‚¹â€ã€‚</p>
          </div>

          <div class="trim-segments">
            <h4 style="margin:0;">å¯¼å‡ºç‰‡æ®µ</h4>
            <p id="trim-status-text" class="hint" style="margin:0;">å°±ç»ª</p>
            <div id="trim-segment-list"></div>
          </div>

          <div id="trim-error-msg" class="error"></div>
        </div>
      </div>

      <!-- SRT TTS Tool Panel -->
      <div class="tool-panel" id="tts-tools">
        <div class="tool-item">
          <h3><span class="icon">ğŸ—£ï¸</span> SRT å­—å¹•è½¬è¯­éŸ³</h3>

          <div style="margin-bottom: 1.5rem;">
            <label style="display:block; margin-bottom:0.5rem; font-weight:500;">TTS æœåŠ¡å™¨åœ°å€</label>
            <input type="text" id="tts-url" placeholder="ä¾‹å¦‚ http://127.0.0.1:8000" style="width:100%; padding:0.6rem; border:1px solid var(--border-color); border-radius:6px; background:var(--bg-primary); color:var(--text-primary);">
            <p class="hint" style="margin-top:0.3rem; font-size: 0.85rem; color: var(--text-secondary);">è¯¥å·¥å…·éœ€è¦é…åˆ Index TTS åç«¯ä½¿ç”¨ã€‚å¦‚æœå½“å‰æ˜¯ HTTPS ç¯å¢ƒï¼Œåç«¯ä¹Ÿéœ€æ”¯æŒ HTTPSã€‚</p>
          </div>

          <div style="margin-bottom: 1.5rem;">
            <label style="display:block; margin-bottom:0.5rem; font-weight:500;">å‚è€ƒéŸ³é¢‘ (éŸ³è‰²å…‹éš†)</label>
            <input type="file" id="ref-audio-input" accept="audio/*" onchange="handleRefAudio(event)">
            <audio id="ref-audio-preview" controls style="width:100%; margin-top:0.5rem; display:none; height: 40px;"></audio>
          </div>

          <div style="margin-bottom: 1.5rem;">
            <label style="display:block; margin-bottom:0.5rem; font-weight:500;">SRT å­—å¹•æ–‡ä»¶</label>
            <input type="file" id="srt-input" accept=".srt" onchange="handleSrtFile(event)">
            <div id="srt-preview" style="margin-top:0.5rem; max-height:200px; overflow-y:auto; background:var(--bg-primary); padding:0.8rem; border-radius:6px; display:none; white-space: pre-wrap; font-family: monospace; font-size: 0.85rem; border: 1px solid var(--border-color); color: var(--text-secondary);"></div>
          </div>

          <div class="btn-group">
            <button class="btn" id="tts-start-btn" onclick="startTTS()">å¼€å§‹ç”Ÿæˆ</button>
            <a id="tts-download-link" class="btn" style="display: none; background: #10b981;" download>ä¸‹è½½è¯­éŸ³</a>
          </div>

          <div id="tts-progress-container" class="progress-container">
            <div style="margin-bottom: 0.5rem; display: flex; justify-content: space-between;">
              <span id="tts-status-text">å‡†å¤‡å°±ç»ª</span>
              <span id="tts-progress-text">0%</span>
            </div>
            <div class="progress-bar-bg">
              <div id="tts-progress-bar" class="progress-bar"></div>
            </div>
            <p id="tts-log-text" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem; font-family: monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></p>
          </div>

          <div id="tts-result-container" class="audio-player-container">
            <h4>ç”Ÿæˆç»“æœé¢„è§ˆ</h4>
            <audio id="tts-result-player" controls></audio>
          </div>

          <div id="tts-error-msg" class="error"></div>
        </div>
      </div>
    </div>
  </main>

  <!-- é¡µè„š -->
  <footer class="footer">
    <div class="container">
      <div class="footer-social">
        <a href="mailto:i@denganliang.com" aria-label="Email">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M.05 3.555A2 2 0 0 1 2 2h12a2 2 0 0 1 1.95 1.555L8 8.414.05 3.555ZM0 4.697v7.104l5.803-3.558L0 4.697ZM6.761 8.83l-6.57 4.027A2 2 0 0 0 2 14h12a2 2 0 0 0 1.808-1.144l-6.57-4.027L8 9.586l-1.239-.757Zm3.436-.586L16 11.801V4.697l-5.803 3.546Z"/>
          </svg>
        </a>
        <a href="https://github.com/denganliang" target="_blank" rel="noopener" aria-label="GitHub">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
          </svg>
        </a>
        <a href="https://twitter.com/denganliang" target="_blank" rel="noopener" aria-label="Twitter">
          <svg width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057a3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z"/>
          </svg>
        </a>
      </div>

      <ul class="footer-links">
        <li><a href="/about/">å…³äº</a></li>
        <li><a href="/blog/">åšå®¢</a></li>
        <li><a href="/projects/">é¡¹ç›®</a></li>
        <li><a href="/tools/">å·¥å…·</a></li>
      </ul>

      <p style="margin-bottom: 0.5rem;">è”ç³»æ–¹å¼: <a href="mailto:i@denganliang.com">i@denganliang.com</a></p>
      <p>&copy; 2026 é‚“å®‰è‰¯. ä¿ç•™æ‰€æœ‰æƒåˆ©.</p>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="/assets/js/theme-switcher.js"></script>
  <script src="/assets/js/i18n.js"></script>
  <script src="/assets/js/main.js"></script>

  <script>
    // ==================== Single Threaded FFmpeg Workaround ====================
    // GitHub Pages doesn't support COOP/COEP headers required for SharedArrayBuffer
    // We must use a single-threaded version of FFmpeg core
    function resolveAssetUrl(assetPath) {
      if (window.location.protocol === 'file:') {
        const prefix = window.location.pathname.includes('/en/tools/') ? '../../assets/' : '../assets/';
        return new URL(prefix + assetPath, window.location.href).href;
      }
      return new URL('/assets/' + assetPath, window.location.href).href;
    }

    const FFMPEG_SCRIPT_URL = resolveAssetUrl('vendor/ffmpeg/ffmpeg.min.js');
    const FFMPEG_CORE_URL = resolveAssetUrl('vendor/ffmpeg/ffmpeg-core.js');
    let ffmpegLibPromise = null;

    function loadFfmpegLib() {
      if (window.FFmpeg) {
        return Promise.resolve(window.FFmpeg);
      }

      if (!ffmpegLibPromise) {
        ffmpegLibPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = FFMPEG_SCRIPT_URL;
          script.async = true;
          script.onload = () => {
            if (window.FFmpeg) {
              resolve(window.FFmpeg);
            } else {
              reject(new Error('FFmpeg loaded but global object not found'));
            }
          };
          script.onerror = () => reject(new Error('Failed to load FFmpeg runtime'));
          document.head.appendChild(script);
        });
      }

      return ffmpegLibPromise;
    }

    // ==================== æ‹–æ‹½ä¸Šä¼ å¤„ç† ====================
    const dropZone = document.getElementById('drop-zone');
    let uploadedFiles = []; // Array of { file, duration, metadata, id, isPlaying }
    let currentPlayingId = null;
    let metadataAudioContext = null;

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, unhighlight, false);
    });

    function highlight(e) {
      dropZone.classList.add('drag-over');
    }

    function unhighlight(e) {
      dropZone.classList.remove('drag-over');
    }

    dropZone.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      handleFiles(files);
    }

    function handleFileSelect(e) {
      const files = e.target.files;
      handleFiles(files);
      // Reset input so same file can be selected again if needed
      e.target.value = '';
    }

    async function handleFiles(files) {
      if (files.length === 0) return;

      const newFiles = Array.from(files).filter(file => file.type.startsWith('audio/'));

      if (newFiles.length === 0) {
        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„éŸ³é¢‘æ–‡ä»¶');
        return;
      }

      // Process new files to get duration/channels/sampleRate/bitrate
      for (const file of newFiles) {
         try {
           const metadata = await getAudioMetadata(file);
           uploadedFiles.push({
             file: file,
             duration: metadata.duration,
             metadata,
             id: Math.random().toString(36).substr(2, 9),
             isPlaying: false
           });
         } catch (e) {
            console.error("Failed to load audio metadata", e);
            const fallbackMetadata = {
              duration: 0,
              channels: 0,
              sampleRate: 0,
              bitrateKbps: 0,
              size: file.size || 0
            };
            uploadedFiles.push({
              file: file,
              duration: 0,
              metadata: fallbackMetadata,
              id: Math.random().toString(36).substr(2, 9),
              isPlaying: false
            });
         }
      }

      updateFileList();
    }

    function getAudioDuration(file) {
      return new Promise((resolve, reject) => {
        const audio = document.createElement('audio');
        const url = URL.createObjectURL(file);
        audio.src = url;

        audio.onloadedmetadata = () => {
           URL.revokeObjectURL(url);
           resolve(audio.duration);
        };

        audio.onerror = () => {
           URL.revokeObjectURL(url);
           resolve(0); // Fail gracefully
        };
      });
    }

    async function getAudioMetadata(file) {
      const metadata = {
        duration: 0,
        channels: 0,
        sampleRate: 0,
        bitrateKbps: 0,
        size: file.size || 0
      };

      metadata.duration = await getAudioDuration(file);

      try {
        if (!metadataAudioContext) {
          metadataAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const arrayBuffer = await file.arrayBuffer();
        const copied = arrayBuffer.slice(0);
        const decoded = await metadataAudioContext.decodeAudioData(copied);
        if (decoded) {
          metadata.duration = Number.isFinite(decoded.duration) ? decoded.duration : metadata.duration;
          metadata.channels = decoded.numberOfChannels || 0;
          metadata.sampleRate = decoded.sampleRate || 0;
        }
      } catch (error) {
        console.warn('Failed to decode audio details', error);
      }

      if (metadata.duration > 0 && metadata.size > 0) {
        metadata.bitrateKbps = (metadata.size * 8) / (metadata.duration * 1000);
      }

      return metadata;
    }

    function formatDuration(seconds) {
       if (!seconds) return '00:00';
       const m = Math.floor(seconds / 60);
       const s = Math.floor(seconds % 60);
       return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function formatBitrateKbps(kbps) {
      if (!Number.isFinite(kbps) || kbps <= 0) return '-';
      return `${Math.round(kbps)} kbps`;
    }

    function formatChannelCount(channels) {
      if (!Number.isFinite(channels) || channels <= 0) return '-';
      return `${Math.round(channels)}ch`;
    }

    function formatSampleRate(sampleRate) {
      if (!Number.isFinite(sampleRate) || sampleRate <= 0) return '-';
      const khz = sampleRate / 1000;
      return `${Number.isInteger(khz) ? khz.toFixed(0) : khz.toFixed(1)} kHz`;
    }

    function buildAudioMetaSummary(metadata, fallbackSize) {
      const safeMeta = metadata || {};
      const duration = formatDuration(safeMeta.duration || 0);
      const size = formatSize(Number.isFinite(safeMeta.size) ? safeMeta.size : (fallbackSize || 0));
      const bitrate = formatBitrateKbps(safeMeta.bitrateKbps);
      const channels = formatChannelCount(safeMeta.channels);
      const sampleRate = formatSampleRate(safeMeta.sampleRate);
      return `${duration} Â· ${size} Â· ${bitrate} Â· ${channels} Â· ${sampleRate}`;
    }

    // Drag and Drop Logic
    let dragSrcEl = null;

    function handleDragStart(e) {
       dragSrcEl = this; // 'this' is the row
       e.dataTransfer.effectAllowed = 'move';
       e.dataTransfer.setData('text/html', this.outerHTML);
       this.classList.add('dragging');
    }

    function handleDragOver(e) {
       if (e.preventDefault) {
          e.preventDefault();
       }
       e.dataTransfer.dropEffect = 'move';
       return false;
    }

    function handleDragEnter(e) {
       this.classList.add('over');
    }

    function handleDragLeave(e) {
       this.classList.remove('over');
    }

    function handleDropItem(e) {
       if (e.stopPropagation) {
          e.stopPropagation();
       }

       if (dragSrcEl !== this) {
          const sourceIndex = parseInt(dragSrcEl.getAttribute('data-index'));
          const targetIndex = parseInt(this.getAttribute('data-index'));

          // Reorder array
          const movedItem = uploadedFiles[sourceIndex];
          uploadedFiles.splice(sourceIndex, 1);
          uploadedFiles.splice(targetIndex, 0, movedItem);
          updateFileList();
       }

       return false;
    }

    function handleDragEnd(e) {
       this.classList.remove('dragging');
       // Remove 'over' from all items
       document.querySelectorAll('.file-list-item').forEach(item => {
          item.classList.remove('over');
       });
    }

    function updateFileList() {
      const listContainer = document.getElementById('file-list-container');
      const uploadText = document.getElementById('upload-text');
      const mergeBtn = document.getElementById('merge-btn');

      if (uploadedFiles.length > 0) {
        listContainer.style.display = 'block';
        uploadText.style.display = 'none';

        listContainer.innerHTML = '';
        uploadedFiles.forEach((item, index) => {
          const div = document.createElement('div');
          div.className = 'file-list-item';
          div.setAttribute('draggable', 'true');
          div.setAttribute('data-index', index);
          div.setAttribute('data-id', item.id);

          // Drag events
          div.addEventListener('dragstart', handleDragStart, false);
          div.addEventListener('dragenter', handleDragEnter, false);
          div.addEventListener('dragover', handleDragOver, false);
          div.addEventListener('dragleave', handleDragLeave, false);
          div.addEventListener('drop', handleDropItem, false);
          div.addEventListener('dragend', handleDragEnd, false);

          const playIcon = item.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';

          div.innerHTML = `
            <div class="drag-handle">â˜°</div>
            <div class="file-info-group">
                <div class="file-name">${index + 1}. ${item.file.name}</div>
                <div class="file-meta">${buildAudioMetaSummary(item.metadata, item.file.size)}</div>
            </div>
            <div class="action-group">
                <button class="icon-btn play-btn" onclick="togglePlay('${item.id}')" title="é¢„è§ˆæ’­æ”¾">${playIcon}</button>
                <button class="icon-btn remove-btn" onclick="removeFile(${index})" title="ç§»é™¤">âœ•</button>
            </div>
          `;
          listContainer.appendChild(div);
        });

        mergeBtn.disabled = uploadedFiles.length < 2;
      } else {
        listContainer.style.display = 'none';
        uploadText.style.display = 'block';
        mergeBtn.disabled = true;
      }
    }

    // Playback Logic
    const previewPlayer = document.getElementById('preview-player');

    previewPlayer.onended = () => {
       if (currentPlayingId) {
          const item = uploadedFiles.find(f => f.id === currentPlayingId);
          if (item) item.isPlaying = false;
          currentPlayingId = null;
          updateFileList();
       }
    };

    function togglePlay(id) {
       const item = uploadedFiles.find(f => f.id === id);
       if (!item) return;

       if (item.isPlaying) {
          // Pause
          previewPlayer.pause();
          item.isPlaying = false;
          currentPlayingId = null;
       } else {
          // Stop others
          uploadedFiles.forEach(f => f.isPlaying = false);

          // Play new
          const url = URL.createObjectURL(item.file);
          previewPlayer.src = url;
          previewPlayer.play();
          item.isPlaying = true;
          currentPlayingId = id;
       }
       updateFileList();
    }

    function removeFile(index) {
      const item = uploadedFiles[index];
      if (item.id === currentPlayingId) {
          previewPlayer.pause();
          currentPlayingId = null;
      }
      uploadedFiles.splice(index, 1);
      updateFileList();
    }

    function formatSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // ==================== éŸ³é¢‘åˆå¹¶é€»è¾‘ ====================
    let createFFmpeg = null;
    let fetchFile = null;
    let ffmpeg = null;

    async function startMerge() {
      if (uploadedFiles.length < 2) return;

      const btn = document.getElementById('merge-btn');
      btn.disabled = true;
      btn.textContent = 'åˆå¹¶ä¸­...';

      document.getElementById('progress-container').style.display = 'block';
      document.getElementById('error-msg').textContent = '';
      document.getElementById('download-link').style.display = 'none';
      document.getElementById('result-player-container').style.display = 'none';

      try {
        if (!createFFmpeg || !fetchFile) {
          updateStatus('åŠ è½½ FFmpeg è¿è¡Œæ—¶...', 0);
          const ffmpegLib = await loadFfmpegLib();
          createFFmpeg = ffmpegLib.createFFmpeg;
          fetchFile = ffmpegLib.fetchFile;
        }

        if (!ffmpeg) {
          updateStatus('åŠ è½½ FFmpeg æ ¸å¿ƒ...', 0);
          ffmpeg = createFFmpeg({
            log: true,
            corePath: FFMPEG_CORE_URL,
            mainName: 'main'
          });

          ffmpeg.setLogger(({ type, message }) => {
            document.getElementById('log-text').textContent = message;
            // FFmpeg progress parsing logic if needed
          });

          await ffmpeg.load();
        }

        updateStatus('å†™å…¥æ–‡ä»¶...', 10);

        // Write all files to FFmpeg FS
        const inputFiles = [];
        for (let i = 0; i < uploadedFiles.length; i++) {
          // Clean filename to avoid issues with special characters in ffmpeg
          const ext = uploadedFiles[i].file.name.split('.').pop();
          const safeName = `input_${i}.${ext}`;
          await ffmpeg.FS('writeFile', safeName, await fetchFile(uploadedFiles[i].file));
          inputFiles.push(safeName);
        }

        // Create concat list file
        // format: file 'filename'
        const listContent = inputFiles.map(f => `file '${f}'`).join('\n');
        await ffmpeg.FS('writeFile', 'list.txt', listContent);

        updateStatus('æ­£åœ¨åˆå¹¶...', 30);

        // Run ffmpeg command
        // -f concat -safe 0 -i list.txt -c copy output.mp3 (if formats are same)
        // To be safe, we re-encode to mp3
        await ffmpeg.run('-f', 'concat', '-safe', '0', '-i', 'list.txt', 'output.mp3');

        updateStatus('è¯»å–ç»“æœ...', 90);
        const data = ffmpeg.FS('readFile', 'output.mp3');

        // Clean up
        for (const f of inputFiles) {
          ffmpeg.FS('unlink', f);
        }
        ffmpeg.FS('unlink', 'list.txt');
        ffmpeg.FS('unlink', 'output.mp3');

        // Create download link
        const blob = new Blob([data.buffer], { type: 'audio/mp3' });
        const url = URL.createObjectURL(blob);

        const downloadLink = document.getElementById('download-link');
        downloadLink.href = url;
        downloadLink.download = `merged_${Date.now()}.mp3`;
        downloadLink.style.display = 'inline-block';

        // Update Result Player
        const resultPlayer = document.getElementById('result-player');
        resultPlayer.src = url;
        document.getElementById('result-player-container').style.display = 'block';

        updateStatus('åˆå¹¶å®Œæˆï¼', 100);
        btn.textContent = 'å¼€å§‹åˆå¹¶';
        btn.disabled = false;

      } catch (e) {
        console.error(e);
        document.getElementById('error-msg').textContent = 'é”™è¯¯: ' + e.message;
        btn.disabled = false;
        btn.textContent = 'å¼€å§‹åˆå¹¶';
      }
    }

    function updateStatus(text, percent) {
      document.getElementById('status-text').textContent = text;
      document.getElementById('progress-text').textContent = percent + '%';
      document.getElementById('progress-bar').style.width = percent + '%';
    }

    function resetMerger() {
      uploadedFiles = [];
      currentPlayingId = null;
      previewPlayer.pause();
      previewPlayer.src = '';

      updateFileList();
      document.getElementById('progress-container').style.display = 'none';
      document.getElementById('download-link').style.display = 'none';
      document.getElementById('result-player-container').style.display = 'none';
      document.getElementById('error-msg').textContent = '';
      if(ffmpeg) {
        try {
            // Clean up if needed
        } catch(e) {}
      }
    }

    // ==================== éŸ³é¢‘å‹ç¼©ï¼ˆWorker + ffmpeg.wasmï¼‰ ====================
    const COMPRESS_WORKER_URL = resolveAssetUrl('js/audio-compress-worker.js');
    const COMPRESS_ALLOWED_EXTENSIONS = new Set(['wav', 'mp3', 'ogg', 'm4a', 'aac', 'flac']);

    const compressorLocale = document.documentElement.lang.startsWith('zh')
      ? {
          waitingFile: 'ç­‰å¾…æ–‡ä»¶',
          loadingRuntime: 'åŠ è½½ FFmpeg è¿è¡Œæ—¶...',
          loadingCore: 'åŠ è½½ FFmpeg æ ¸å¿ƒ...',
          encoding: 'æ­£åœ¨ç¼–ç ...',
          readingResult: 'è¯»å–å‹ç¼©ç»“æœ...',
          completed: 'å‹ç¼©å®Œæˆ',
          unsupportedFile: 'è¯·é€‰æ‹©æœ‰æ•ˆéŸ³é¢‘æ–‡ä»¶ï¼ˆwav/mp3/ogg/m4a/aac/flacï¼‰',
          chooseFile: 'è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶',
          compressingBtn: 'å‹ç¼©ä¸­...',
          cancelingBtn: 'å–æ¶ˆä¸­...',
          cancelBtn: 'å–æ¶ˆ',
          startBtn: 'å¼€å§‹å‹ç¼©',
          ratioLarger: 'ä½“ç§¯å¢å¤§',
          selectedFile: 'å·²é€‰æ‹©',
          workerFailed: 'æµè§ˆå™¨ä¸æ”¯æŒ Web Workerï¼Œæ— æ³•æœ¬åœ°å‹ç¼©',
          aacCodecHint: 'å½“å‰ ffmpeg.wasm æ„å»ºå¯èƒ½ä¸æ”¯æŒ AAC ç¼–ç ï¼Œè¯·åˆ‡æ¢ MP3/OGG',
          busyHint: 'å·²æœ‰å‹ç¼©ä»»åŠ¡åœ¨è¿›è¡Œï¼Œè¯·ç­‰å¾…å®Œæˆåå†è¯•',
          canceled: 'å·²å–æ¶ˆ',
          errorPrefix: 'é”™è¯¯: '
        }
      : {
          waitingFile: 'Waiting for file',
          loadingRuntime: 'Loading FFmpeg runtime...',
          loadingCore: 'Loading FFmpeg core...',
          encoding: 'Encoding...',
          readingResult: 'Reading output...',
          completed: 'Compression completed',
          unsupportedFile: 'Please select a valid audio file (wav/mp3/ogg/m4a/aac/flac)',
          chooseFile: 'Please select an audio file first',
          compressingBtn: 'Compressing...',
          cancelingBtn: 'Canceling...',
          cancelBtn: 'Cancel',
          startBtn: 'Start Compress',
          ratioLarger: 'Larger by',
          selectedFile: 'Selected',
          workerFailed: 'Web Worker is not supported in this browser',
          aacCodecHint: 'This ffmpeg.wasm build may not support AAC encoding. Try MP3/OGG.',
          busyHint: 'Another compression task is still running. Please wait.',
          canceled: 'Canceled',
          errorPrefix: 'Error: '
        };

    const compressDropZone = document.getElementById('compress-drop-zone');
    const compressFileInput = document.getElementById('compress-file-input');
    const compressFileInfo = document.getElementById('compress-file-info');
    const compressUploadText = document.getElementById('compress-upload-text');
    const compressStartBtn = document.getElementById('compress-start-btn');
    const compressCancelBtn = document.getElementById('compress-cancel-btn');
    const compressDownloadLink = document.getElementById('compress-download-link');
    const compressResultContainer = document.getElementById('compress-result-container');
    const compressResultPlayer = document.getElementById('compress-result-player');
    const compressProgressContainer = document.getElementById('compress-progress-container');
    const compressStatusText = document.getElementById('compress-status-text');
    const compressProgressText = document.getElementById('compress-progress-text');
    const compressProgressBar = document.getElementById('compress-progress-bar');
    const compressLogText = document.getElementById('compress-log-text');
    const compressErrorMsg = document.getElementById('compress-error-msg');
    const compressInputSizeEl = document.getElementById('compress-input-size');
    const compressOutputSizeEl = document.getElementById('compress-output-size');
    const compressRatioEl = document.getElementById('compress-ratio');
    const compressOutputFormatEl = document.getElementById('compress-output-format');
    const compressBitrateEl = document.getElementById('compress-bitrate');
    const compressChannelsEl = document.getElementById('compress-channels');
    const compressSampleRateEl = document.getElementById('compress-sample-rate');

    let compressWorker = null;
    let compressFile = null;
    let compressFileMetadata = null;
    let compressOutputUrl = null;
    let compressRequestId = null;
    let compressInProgress = false;
    let compressCanceling = false;
    let compressProgressValue = 0;

    function escapeHtml(value) {
      return String(value)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function getFileExtension(fileName) {
      const index = fileName.lastIndexOf('.');
      if (index === -1) {
        return '';
      }
      return fileName.slice(index + 1).toLowerCase();
    }

    function getBaseName(fileName) {
      const index = fileName.lastIndexOf('.');
      if (index === -1) {
        return fileName || 'audio';
      }
      return fileName.slice(0, index);
    }

    function isSupportedCompressFile(file) {
      if (!file) return false;
      const extension = getFileExtension(file.name || '');
      if (COMPRESS_ALLOWED_EXTENSIONS.has(extension)) {
        return true;
      }
      return typeof file.type === 'string' && file.type.startsWith('audio/');
    }

    function updateCompressStatus(text, percent) {
      compressStatusText.textContent = text;
      compressProgressValue = Math.max(0, Math.min(100, Math.round(percent)));
      compressProgressText.textContent = compressProgressValue + '%';
      compressProgressBar.style.width = compressProgressValue + '%';
    }

    function setCompressError(message) {
      compressErrorMsg.textContent = message || '';
    }

    function revokeCompressOutputUrl() {
      if (compressOutputUrl) {
        URL.revokeObjectURL(compressOutputUrl);
        compressOutputUrl = null;
      }
    }

    function clearCompressResult() {
      revokeCompressOutputUrl();
      compressDownloadLink.style.display = 'none';
      compressDownloadLink.removeAttribute('href');
      compressResultPlayer.src = '';
      compressResultContainer.style.display = 'none';
      compressOutputSizeEl.textContent = '-';
      compressRatioEl.textContent = '-';
    }

    function renderCompressFileInfo() {
      if (!compressFile) {
        compressUploadText.style.display = 'block';
        compressFileInfo.style.display = 'none';
        compressFileInfo.innerHTML = '';
        compressStartBtn.disabled = true;
        compressCancelBtn.disabled = true;
        compressInputSizeEl.textContent = '-';
        return;
      }

      compressUploadText.style.display = 'none';
      compressFileInfo.style.display = 'block';
      compressFileInfo.innerHTML = `
        <div class="file-list-item">
          <div class="file-info-group">
            <span class="file-name">${escapeHtml(compressFile.name)}</span>
            <span class="file-meta">${buildAudioMetaSummary(compressFileMetadata, compressFile.size)}</span>
          </div>
        </div>
      `;

      compressInputSizeEl.textContent = formatSize(compressFile.size);
      compressStartBtn.disabled = compressInProgress;
      compressCancelBtn.disabled = !compressInProgress;
    }

    function onCompressFormatChange() {
      const isWav = compressOutputFormatEl.value === 'wav';
      compressBitrateEl.disabled = isWav;
    }

    function ensureCompressWorker() {
      if (compressWorker) {
        return true;
      }
      if (typeof Worker === 'undefined') {
        setCompressError(compressorLocale.workerFailed);
        return false;
      }

      compressWorker = new Worker(COMPRESS_WORKER_URL);
      compressWorker.onmessage = onCompressWorkerMessage;
      compressWorker.onerror = (event) => {
        console.error(event);
        compressInProgress = false;
        compressCanceling = false;
        compressStartBtn.disabled = !compressFile;
        compressStartBtn.textContent = compressorLocale.startBtn;
        compressCancelBtn.disabled = true;
        compressCancelBtn.textContent = compressorLocale.cancelBtn;
        setCompressError(event.message || 'Worker error');
      };
      return true;
    }

    function onCompressWorkerMessage(event) {
      const message = event.data || {};

      if (message.type === 'status') {
        if (message.code === 'loading-runtime') {
          updateCompressStatus(compressorLocale.loadingRuntime, 5);
        } else if (message.code === 'loading-core') {
          updateCompressStatus(compressorLocale.loadingCore, 15);
        } else if (message.code === 'canceling' && message.id === compressRequestId) {
          compressCanceling = true;
          compressCancelBtn.disabled = true;
          compressCancelBtn.textContent = compressorLocale.cancelingBtn;
          updateCompressStatus(compressorLocale.cancelingBtn, Math.max(5, compressProgressValue));
        } else if (message.code === 'encoding' && message.id === compressRequestId) {
          updateCompressStatus(compressorLocale.encoding, Math.max(25, compressProgressValue));
        }
        return;
      }

      if (message.type === 'progress') {
        if (!compressInProgress) return;
        const ratio = typeof message.ratio === 'number' ? message.ratio : 0;
        const percent = Math.max(compressProgressValue, Math.round(25 + Math.min(1, Math.max(0, ratio)) * 70));
        updateCompressStatus(compressorLocale.encoding, percent);
        return;
      }

      if (message.type === 'log') {
        compressLogText.textContent = message.message || '';
        return;
      }

      if (message.type === 'error') {
        if (message.id && message.id !== compressRequestId) {
          return;
        }
        compressInProgress = false;
        compressCanceling = false;
        compressStartBtn.disabled = !compressFile;
        compressStartBtn.textContent = compressorLocale.startBtn;
        compressCancelBtn.disabled = true;
        compressCancelBtn.textContent = compressorLocale.cancelBtn;
        let errorMessage = message.message || 'Unknown error';
        if (compressOutputFormatEl.value === 'aac' && /unknown encoder|encoder .* not found/i.test(errorMessage)) {
          errorMessage = `${errorMessage}ï¼›${compressorLocale.aacCodecHint}`;
        }
        if (/another compression task is still running/i.test(errorMessage)) {
          errorMessage = compressorLocale.busyHint;
        }
        setCompressError(compressorLocale.errorPrefix + errorMessage);
        return;
      }

      if (message.type === 'canceled') {
        if (message.id && message.id !== compressRequestId) {
          return;
        }
        compressInProgress = false;
        compressCanceling = false;
        compressRequestId = null;
        compressStartBtn.disabled = !compressFile;
        compressStartBtn.textContent = compressorLocale.startBtn;
        compressCancelBtn.disabled = true;
        compressCancelBtn.textContent = compressorLocale.cancelBtn;
        updateCompressStatus(compressorLocale.canceled, 0);
        compressLogText.textContent = '';
        return;
      }

      if (message.type === 'done') {
        if (message.id !== compressRequestId || !compressFile) {
          return;
        }

        updateCompressStatus(compressorLocale.readingResult, 98);

        const blob = new Blob([message.outputBuffer], { type: message.mimeType || 'application/octet-stream' });
        revokeCompressOutputUrl();
        compressOutputUrl = URL.createObjectURL(blob);

        const baseName = getBaseName(compressFile.name || 'audio');
        const outputExt = message.outputFormat || compressOutputFormatEl.value || 'mp3';

        compressDownloadLink.href = compressOutputUrl;
        compressDownloadLink.download = `${baseName}_compressed.${outputExt}`;
        compressDownloadLink.style.display = 'inline-block';

        compressResultPlayer.src = compressOutputUrl;
        compressResultContainer.style.display = 'block';

        compressOutputSizeEl.textContent = formatSize(blob.size);
        if (compressFile.size > 0) {
          const ratio = (1 - blob.size / compressFile.size) * 100;
          compressRatioEl.textContent = ratio >= 0
            ? `${ratio.toFixed(1)}%`
            : `${compressorLocale.ratioLarger} ${Math.abs(ratio).toFixed(1)}%`;
        } else {
          compressRatioEl.textContent = '-';
        }

        compressInProgress = false;
        compressCanceling = false;
        compressStartBtn.disabled = false;
        compressStartBtn.textContent = compressorLocale.startBtn;
        compressCancelBtn.disabled = true;
        compressCancelBtn.textContent = compressorLocale.cancelBtn;
        updateCompressStatus(compressorLocale.completed, 100);
      }
    }

    function applyCompressFile(file) {
      if (!file) return;
      if (!isSupportedCompressFile(file)) {
        setCompressError(compressorLocale.unsupportedFile);
        return;
      }

      compressFile = file;
      compressFileMetadata = {
        duration: 0,
        channels: 0,
        sampleRate: 0,
        bitrateKbps: 0,
        size: file.size || 0
      };
      clearCompressResult();
      setCompressError('');
      compressLogText.textContent = `${compressorLocale.selectedFile}: ${file.name}`;
      renderCompressFileInfo();

      const pendingFile = file;
      getAudioMetadata(file).then((metadata) => {
        if (compressFile === pendingFile) {
          compressFileMetadata = metadata;
          renderCompressFileInfo();
        }
      }).catch((error) => {
        console.warn('Failed to load compressor metadata', error);
      });
    }

    function handleCompressDrop(event) {
      const files = event.dataTransfer ? event.dataTransfer.files : null;
      if (!files || files.length === 0) {
        return;
      }

      const file = Array.from(files).find(isSupportedCompressFile);
      if (!file) {
        setCompressError(compressorLocale.unsupportedFile);
        return;
      }

      applyCompressFile(file);
    }

    function handleCompressFileSelect(event) {
      const file = event.target && event.target.files ? event.target.files[0] : null;
      if (file) {
        applyCompressFile(file);
      }
      if (event.target) {
        event.target.value = '';
      }
    }

    async function startCompress() {
      if (compressInProgress) return;
      if (!compressFile) {
        setCompressError(compressorLocale.chooseFile);
        return;
      }

      if (!ensureCompressWorker()) {
        return;
      }

      compressInProgress = true;
      compressCanceling = false;
      compressRequestId = Date.now();
      compressStartBtn.disabled = true;
      compressStartBtn.textContent = compressorLocale.compressingBtn;
      compressCancelBtn.disabled = false;
      compressCancelBtn.textContent = compressorLocale.cancelBtn;
      compressProgressContainer.style.display = 'block';
      clearCompressResult();
      setCompressError('');
      compressLogText.textContent = '';
      updateCompressStatus(compressorLocale.loadingRuntime, 3);

      try {
        const inputBuffer = await compressFile.arrayBuffer();
        compressWorker.postMessage(
          {
            type: 'compress',
            id: compressRequestId,
            inputName: compressFile.name,
            inputBuffer,
            outputFormat: compressOutputFormatEl.value,
            bitrate: Number(compressBitrateEl.value),
            channels: compressChannelsEl.value,
            sampleRate: compressSampleRateEl.value
          },
          [inputBuffer]
        );
      } catch (error) {
        compressInProgress = false;
        compressCanceling = false;
        compressStartBtn.disabled = false;
        compressStartBtn.textContent = compressorLocale.startBtn;
        compressCancelBtn.disabled = true;
        compressCancelBtn.textContent = compressorLocale.cancelBtn;
        setCompressError(compressorLocale.errorPrefix + (error.message || String(error)));
      }
    }

    function cancelCompress() {
      if (!compressInProgress || !compressWorker || compressCanceling) {
        return;
      }

      compressCanceling = true;
      compressCancelBtn.disabled = true;
      compressCancelBtn.textContent = compressorLocale.cancelingBtn;
      updateCompressStatus(compressorLocale.cancelingBtn, Math.max(5, compressProgressValue));
      compressWorker.postMessage({ type: 'cancel', id: compressRequestId });
    }

    function resetCompressor() {
      compressInProgress = false;
      compressCanceling = false;
      compressRequestId = null;
      compressFile = null;
      compressFileMetadata = null;
      clearCompressResult();
      renderCompressFileInfo();
      compressLogText.textContent = '';
      setCompressError('');
      compressProgressContainer.style.display = 'none';
      updateCompressStatus(compressorLocale.waitingFile, 0);
      compressStartBtn.textContent = compressorLocale.startBtn;
      compressStartBtn.disabled = true;
      compressCancelBtn.textContent = compressorLocale.cancelBtn;
      compressCancelBtn.disabled = true;
    }

    if (compressDropZone) {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach((eventName) => {
        compressDropZone.addEventListener(eventName, preventDefaults, false);
      });

      ['dragenter', 'dragover'].forEach((eventName) => {
        compressDropZone.addEventListener(eventName, () => compressDropZone.classList.add('drag-over'), false);
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        compressDropZone.addEventListener(eventName, () => compressDropZone.classList.remove('drag-over'), false);
      });

      compressDropZone.addEventListener('drop', handleCompressDrop, false);
    }

    onCompressFormatChange();
    resetCompressor();

    // ==================== éŸ³é¢‘æ‰“ç‚¹å‰ªè¾‘ï¼ˆWebAudio æœ¬åœ°ï¼‰ ====================
    const trimLocale = document.documentElement.lang.startsWith('zh')
      ? {
          noFile: 'è¯·å…ˆä¸Šä¼ éŸ³é¢‘æ–‡ä»¶',
          invalidRange: 'è£å‰ªåŒºé—´æ— æ•ˆï¼Œè¯·ç¡®ä¿ç»“æŸæ—¶é—´å¤§äºå¼€å§‹æ—¶é—´',
          decodeFailed: 'éŸ³é¢‘è§£æå¤±è´¥ï¼Œè¯·æ¢ä¸€ä¸ªæ–‡ä»¶é‡è¯•',
          trimDone: 'è£å‰ªå®Œæˆ',
          splitDone: 'åˆ†å‰²å®Œæˆ',
          startEndHint: 'å¼€å§‹: ',
          endHint: 'ç»“æŸ: ',
          durationText: 'æ€»æ—¶é•¿ï¼š',
          noPoints: 'è¿˜æ²¡æœ‰æ‰“ç‚¹ï¼Œæ’­æ”¾åˆ°ç›®æ ‡æ—¶é—´åç‚¹â€œæ·»åŠ æ‰“ç‚¹â€ã€‚',
          segmentLabel: 'ç‰‡æ®µ',
          downloadLabel: 'ä¸‹è½½',
          removeLabel: 'ç§»é™¤',
          currentText: 'å½“å‰',
          timeFormat: 'ç§’',
          atLeastOnePoint: 'è¯·è‡³å°‘æ·»åŠ ä¸€ä¸ªæ‰“ç‚¹åå†åˆ†å‰²',
          statusReady: 'å°±ç»ª',
          statusEncoding: 'æ­£åœ¨ç¼–ç ç‰‡æ®µ',
          statusDone: 'å¯¼å‡ºå®Œæˆ',
          formatHintAac: 'å½“å‰ ffmpeg.wasm å¯èƒ½ä¸æ”¯æŒ AACï¼Œè¯·åˆ‡æ¢ MP3/OGG'
        }
      : {
          noFile: 'Please upload an audio file first',
          invalidRange: 'Invalid range: end must be greater than start',
          decodeFailed: 'Failed to decode audio. Please try another file.',
          trimDone: 'Trim completed',
          splitDone: 'Split completed',
          startEndHint: 'Start: ',
          endHint: 'End: ',
          durationText: 'Duration: ',
          noPoints: 'No cue points yet. Move playback and click â€œAdd Cue Pointâ€.',
          segmentLabel: 'Segment',
          downloadLabel: 'Download',
          removeLabel: 'Remove',
          currentText: 'Current',
          timeFormat: 's',
          atLeastOnePoint: 'Add at least one cue point before splitting',
          statusReady: 'Ready',
          statusEncoding: 'Encoding segment',
          statusDone: 'Export completed',
          formatHintAac: 'Current ffmpeg.wasm build may not support AAC. Try MP3/OGG.'
        };

    const trimDropZone = document.getElementById('trim-drop-zone');
    const trimFileInput = document.getElementById('trim-file-input');
    const trimUploadText = document.getElementById('trim-upload-text');
    const trimFileInfo = document.getElementById('trim-file-info');
    const trimPlayerWrap = document.getElementById('trim-player-wrap');
    const trimPlayer = document.getElementById('trim-player');
    const trimCurrentTime = document.getElementById('trim-current-time');
    const trimStartInput = document.getElementById('trim-start');
    const trimEndInput = document.getElementById('trim-end');
    const trimSetStartBtn = document.getElementById('trim-set-start-btn');
    const trimSetEndBtn = document.getElementById('trim-set-end-btn');
    const trimCutBtn = document.getElementById('trim-cut-btn');
    const trimAddPointBtn = document.getElementById('trim-add-point-btn');
    const trimSplitBtn = document.getElementById('trim-split-btn');
    const trimClearPointsBtn = document.getElementById('trim-clear-points-btn');
    const trimDurationText = document.getElementById('trim-duration-text');
    const trimPointList = document.getElementById('trim-point-list');
    const trimPointEmpty = document.getElementById('trim-point-empty');
    const trimOutputFormatEl = document.getElementById('trim-output-format');
    const trimBitrateEl = document.getElementById('trim-bitrate');
    const trimStatusText = document.getElementById('trim-status-text');
    const trimSegmentList = document.getElementById('trim-segment-list');
    const trimErrorMsg = document.getElementById('trim-error-msg');

    let trimSourceFile = null;
    let trimSourceMetadata = null;
    let trimSourceUrl = null;
    let trimAudioContext = null;
    let trimDecodedBuffer = null;
    let trimCuePoints = [];
    let trimSegmentUrls = [];
    let trimWorker = null;
    let trimJobSeq = 0;

    function formatTimeSec(value) {
      const total = Number.isFinite(value) ? Math.max(0, value) : 0;
      const m = Math.floor(total / 60);
      const s = total - m * 60;
      return `${String(m).padStart(2, '0')}:${s.toFixed(2).padStart(5, '0')}`;
    }

    function setTrimError(message) {
      trimErrorMsg.textContent = message || '';
    }

    function setTrimStatus(text) {
      if (trimStatusText) {
        trimStatusText.textContent = text || '';
      }
    }

    function onTrimFormatChange() {
      if (!trimOutputFormatEl || !trimBitrateEl) return;
      trimBitrateEl.disabled = trimOutputFormatEl.value === 'wav';
    }

    function ensureTrimWorker() {
      if (trimWorker) return trimWorker;
      trimWorker = new Worker(COMPRESS_WORKER_URL);
      return trimWorker;
    }

    function clearTrimSegments() {
      trimSegmentUrls.forEach((url) => URL.revokeObjectURL(url));
      trimSegmentUrls = [];
      trimSegmentList.innerHTML = '';
    }

    function updateTrimPointList() {
      if (!trimPointList) return;
      if (trimCuePoints.length === 0) {
        trimPointList.innerHTML = '';
        trimPointEmpty.style.display = 'block';
        trimSplitBtn.disabled = true;
        trimClearPointsBtn.disabled = true;
        return;
      }

      trimPointEmpty.style.display = 'none';
      trimSplitBtn.disabled = false;
      trimClearPointsBtn.disabled = false;
      trimPointList.innerHTML = trimCuePoints.map((point, index) => `
        <span class="trim-point-tag">
          ${formatTimeSec(point)}
          <button type="button" onclick="removeTrimPoint(${index})" aria-label="${trimLocale.removeLabel}">Ã—</button>
        </span>
      `).join('');
    }

    function updateTrimCurrentTime() {
      if (!trimPlayer) return;
      trimCurrentTime.textContent = formatTimeSec(trimPlayer.currentTime || 0);
    }

    function setTrimControlsEnabled(enabled) {
      trimSetStartBtn.disabled = !enabled;
      trimSetEndBtn.disabled = !enabled;
      trimCutBtn.disabled = !enabled;
      trimAddPointBtn.disabled = !enabled;
      trimSplitBtn.disabled = !enabled || trimCuePoints.length === 0;
      trimClearPointsBtn.disabled = !enabled || trimCuePoints.length === 0;
      trimStartInput.disabled = !enabled;
      trimEndInput.disabled = !enabled;
    }

    function renderTrimFileInfo() {
      if (!trimSourceFile) {
        trimUploadText.style.display = 'block';
        trimFileInfo.style.display = 'none';
        trimFileInfo.innerHTML = '';
        trimPlayerWrap.style.display = 'none';
        trimDurationText.textContent = `${trimLocale.durationText}-`;
        setTrimControlsEnabled(false);
        return;
      }

      trimUploadText.style.display = 'none';
      trimFileInfo.style.display = 'block';
      trimFileInfo.innerHTML = `
        <div class="file-list-item">
          <div class="file-info-group">
            <span class="file-name">${escapeHtml(trimSourceFile.name)}</span>
            <span class="file-meta">${buildAudioMetaSummary(trimSourceMetadata, trimSourceFile.size)}</span>
          </div>
        </div>
      `;
      trimPlayerWrap.style.display = 'block';
      setTrimControlsEnabled(true);
    }

    async function decodeTrimFile(file) {
      try {
        if (!trimAudioContext) {
          trimAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const arrayBuffer = await file.arrayBuffer();
        const copied = arrayBuffer.slice(0);
        trimDecodedBuffer = await trimAudioContext.decodeAudioData(copied);
      } catch (error) {
        trimDecodedBuffer = null;
        throw error;
      }
    }

    async function applyTrimFile(file) {
      if (!file || !(file.type || '').startsWith('audio/')) {
        setTrimError(trimLocale.noFile);
        return;
      }

      setTrimError('');
      clearTrimSegments();
      trimCuePoints = [];
      updateTrimPointList();

      if (trimSourceUrl) {
        URL.revokeObjectURL(trimSourceUrl);
      }
      trimSourceFile = file;
      trimSourceMetadata = {
        duration: 0,
        channels: 0,
        sampleRate: 0,
        bitrateKbps: 0,
        size: file.size || 0
      };
      trimSourceUrl = URL.createObjectURL(file);
      trimPlayer.src = trimSourceUrl;
      trimPlayer.currentTime = 0;
      updateTrimCurrentTime();
      renderTrimFileInfo();

      try {
        await decodeTrimFile(file);
      } catch (error) {
        setTrimError(trimLocale.decodeFailed);
        return;
      }

      const duration = trimDecodedBuffer ? trimDecodedBuffer.duration : 0;
      trimSourceMetadata = {
        duration,
        channels: trimDecodedBuffer ? (trimDecodedBuffer.numberOfChannels || 0) : 0,
        sampleRate: trimDecodedBuffer ? (trimDecodedBuffer.sampleRate || 0) : 0,
        bitrateKbps: duration > 0 ? (file.size * 8) / (duration * 1000) : 0,
        size: file.size || 0
      };
      trimDurationText.textContent = `${trimLocale.durationText}${formatTimeSec(duration)}`;
      trimStartInput.value = '0';
      trimEndInput.value = duration > 0 ? duration.toFixed(2) : '0';
      setTrimStatus(trimLocale.statusReady);
      renderTrimFileInfo();
    }

    function audioBufferToWavBlob(buffer, startSec, endSec) {
      const sampleRate = buffer.sampleRate;
      const channels = buffer.numberOfChannels;
      const safeStart = Math.max(0, Math.min(startSec, buffer.duration));
      const safeEnd = Math.max(safeStart, Math.min(endSec, buffer.duration));
      const startOffset = Math.floor(safeStart * sampleRate);
      const endOffset = Math.floor(safeEnd * sampleRate);
      const length = Math.max(1, endOffset - startOffset);
      const bytesPerSample = 2;
      const blockAlign = channels * bytesPerSample;
      const dataSize = length * blockAlign;
      const wavBuffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(wavBuffer);

      function writeString(offset, text) {
        for (let i = 0; i < text.length; i++) {
          view.setUint8(offset + i, text.charCodeAt(i));
        }
      }

      writeString(0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, channels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, dataSize, true);

      let offset = 44;
      for (let i = 0; i < length; i++) {
        for (let channel = 0; channel < channels; channel++) {
          const sample = buffer.getChannelData(channel)[startOffset + i] || 0;
          const clamped = Math.max(-1, Math.min(1, sample));
          const intSample = clamped < 0 ? clamped * 32768 : clamped * 32767;
          view.setInt16(offset, intSample, true);
          offset += 2;
        }
      }

      return new Blob([wavBuffer], { type: 'audio/wav' });
    }

    function appendTrimSegment(blob, startSec, endSec, indexHint, fileExt) {
      const url = URL.createObjectURL(blob);
      trimSegmentUrls.push(url);
      const idx = indexHint || trimSegmentUrls.length;
      const ext = fileExt || 'wav';
      const item = document.createElement('div');
      item.className = 'trim-segment-item';
      item.innerHTML = `
        <div class="trim-segment-head">
          <span>${trimLocale.segmentLabel} ${idx} Â· ${formatTimeSec(startSec)} - ${formatTimeSec(endSec)}</span>
          <span>${formatSize(blob.size)}</span>
        </div>
        <audio controls src="${url}"></audio>
        <div class="btn-group">
          <a class="btn" href="${url}" download="segment_${idx}_${Math.round(startSec*100)/100}-${Math.round(endSec*100)/100}.${ext}">${trimLocale.downloadLabel}</a>
        </div>
      `;
      trimSegmentList.appendChild(item);
    }

    async function encodeTrimBlob(wavBlob, format, bitrate, idx) {
      if (format === 'wav') {
        return {
          blob: wavBlob,
          ext: 'wav'
        };
      }

      const worker = ensureTrimWorker();
      const id = ++trimJobSeq;
      const inputBuffer = await wavBlob.arrayBuffer();
      setTrimStatus(`${trimLocale.statusEncoding} ${idx}...`);

      return new Promise((resolve, reject) => {
        const onMessage = (event) => {
          const message = event.data || {};
          if (message.id !== id) return;

          if (message.type === 'done') {
            worker.removeEventListener('message', onMessage);
            const outBlob = new Blob([message.outputBuffer], { type: message.mimeType || 'application/octet-stream' });
            resolve({ blob: outBlob, ext: format });
            return;
          }

          if (message.type === 'error') {
            worker.removeEventListener('message', onMessage);
            let msg = message.message || 'encode error';
            if (format === 'aac' && /unknown encoder|encoder .* not found/i.test(msg)) {
              msg = `${msg}ï¼›${trimLocale.formatHintAac}`;
            }
            reject(new Error(msg));
          }
        };

        worker.addEventListener('message', onMessage);
        worker.postMessage({
          type: 'compress',
          id,
          inputName: `trim_${id}.wav`,
          inputBuffer,
          outputFormat: format,
          bitrate: Number(bitrate),
          channels: 'stereo',
          sampleRate: 'keep'
        }, [inputBuffer]);
      });
    }

    function handleTrimFileSelect(event) {
      const file = event.target && event.target.files ? event.target.files[0] : null;
      if (file) {
        applyTrimFile(file);
      }
      if (event.target) {
        event.target.value = '';
      }
    }

    function handleTrimDrop(event) {
      const files = event.dataTransfer ? event.dataTransfer.files : null;
      if (!files || files.length === 0) return;
      const file = Array.from(files).find((f) => (f.type || '').startsWith('audio/'));
      if (file) {
        applyTrimFile(file);
      }
    }

    function setTrimBoundary(which) {
      if (!trimSourceFile) {
        setTrimError(trimLocale.noFile);
        return;
      }
      const current = trimPlayer.currentTime || 0;
      if (which === 'start') {
        trimStartInput.value = current.toFixed(2);
      } else {
        trimEndInput.value = current.toFixed(2);
      }
    }

    async function cutTrimRange() {
      if (!trimDecodedBuffer) {
        setTrimError(trimLocale.noFile);
        return;
      }
      const start = Number(trimStartInput.value);
      const end = Number(trimEndInput.value);
      if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) {
        setTrimError(trimLocale.invalidRange);
        return;
      }

      setTrimError('');
      clearTrimSegments();
      setTrimStatus(trimLocale.statusEncoding);
      try {
        const wavBlob = audioBufferToWavBlob(trimDecodedBuffer, start, end);
        const format = trimOutputFormatEl.value;
        const bitrate = trimBitrateEl.value;
        const encoded = await encodeTrimBlob(wavBlob, format, bitrate, 1);
        appendTrimSegment(encoded.blob, start, end, 1, encoded.ext);
        setTrimStatus(trimLocale.statusDone);
      } catch (error) {
        setTrimError(trimLocale.errorPrefix ? trimLocale.errorPrefix + error.message : error.message);
        setTrimStatus(trimLocale.statusReady);
      }
    }

    function addTrimPoint() {
      if (!trimDecodedBuffer) {
        setTrimError(trimLocale.noFile);
        return;
      }
      const current = trimPlayer.currentTime || 0;
      const rounded = Math.round(current * 100) / 100;
      if (trimCuePoints.some((point) => Math.abs(point - rounded) < 0.01)) {
        return;
      }
      trimCuePoints.push(rounded);
      trimCuePoints.sort((a, b) => a - b);
      updateTrimPointList();
    }

    function removeTrimPoint(index) {
      trimCuePoints.splice(index, 1);
      updateTrimPointList();
    }

    function clearTrimPoints() {
      trimCuePoints = [];
      updateTrimPointList();
    }

    async function splitByTrimPoints() {
      if (!trimDecodedBuffer) {
        setTrimError(trimLocale.noFile);
        return;
      }
      if (trimCuePoints.length === 0) {
        setTrimError(trimLocale.atLeastOnePoint);
        return;
      }

      setTrimError('');
      clearTrimSegments();
      setTrimStatus(trimLocale.statusEncoding);
      const duration = trimDecodedBuffer.duration;
      const points = [0, ...trimCuePoints.filter((p) => p > 0 && p < duration), duration]
        .sort((a, b) => a - b);

      let segmentIndex = 1;
      try {
        for (let i = 0; i < points.length - 1; i++) {
          const start = points[i];
          const end = points[i + 1];
          if (end - start < 0.02) continue;
          const wavBlob = audioBufferToWavBlob(trimDecodedBuffer, start, end);
          const format = trimOutputFormatEl.value;
          const bitrate = trimBitrateEl.value;
          const encoded = await encodeTrimBlob(wavBlob, format, bitrate, segmentIndex);
          appendTrimSegment(encoded.blob, start, end, segmentIndex, encoded.ext);
          segmentIndex += 1;
        }
        setTrimStatus(trimLocale.statusDone);
      } catch (error) {
        setTrimError(trimLocale.errorPrefix ? trimLocale.errorPrefix + error.message : error.message);
        setTrimStatus(trimLocale.statusReady);
      }
    }

    if (trimPlayer) {
      trimPlayer.addEventListener('timeupdate', updateTrimCurrentTime);
    }

    if (trimDropZone) {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach((eventName) => {
        trimDropZone.addEventListener(eventName, preventDefaults, false);
      });

      ['dragenter', 'dragover'].forEach((eventName) => {
        trimDropZone.addEventListener(eventName, () => trimDropZone.classList.add('drag-over'), false);
      });

      ['dragleave', 'drop'].forEach((eventName) => {
        trimDropZone.addEventListener(eventName, () => trimDropZone.classList.remove('drag-over'), false);
      });

      trimDropZone.addEventListener('drop', handleTrimDrop, false);
    }

    window.handleTrimFileSelect = handleTrimFileSelect;
    window.setTrimBoundary = setTrimBoundary;
    window.cutTrimRange = cutTrimRange;
    window.onTrimFormatChange = onTrimFormatChange;
    window.addTrimPoint = addTrimPoint;
    window.removeTrimPoint = removeTrimPoint;
    window.clearTrimPoints = clearTrimPoints;
    window.splitByTrimPoints = splitByTrimPoints;

    setTrimControlsEnabled(false);
    onTrimFormatChange();
    setTrimStatus(trimLocale.statusReady);
    updateTrimPointList();

    // ==================== Tab Switching ====================
    function switchTab(tabId) {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabId);
      });
      document.querySelectorAll('.tool-panel').forEach(panel => {
        panel.classList.toggle('active', panel.id === tabId);
      });
    }

    // ==================== TTS Logic ====================
    let refAudioFile = null;
    let srtSegments = [];

    // Load saved URL
    const savedUrl = localStorage.getItem('tts_api_url');
    if (savedUrl) {
      document.getElementById('tts-url').value = savedUrl;
    }

    function handleRefAudio(e) {
      const file = e.target.files[0];
      if (!file) return;
      refAudioFile = file;

      const audio = document.getElementById('ref-audio-preview');
      audio.src = URL.createObjectURL(file);
      audio.style.display = 'block';
    }

    function handleSrtFile(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        document.getElementById('srt-preview').textContent = text;
        document.getElementById('srt-preview').style.display = 'block';
        srtSegments = parseSrt(text);
        console.log(`Parsed ${srtSegments.length} segments`);
      };
      reader.readAsText(file);
    }

    function parseTime(timeStr) {
      // 00:00:00,000 -> seconds
      try {
        const [hms, ms] = timeStr.split(',');
        const [h, m, s] = hms.split(':').map(Number);
        return h * 3600 + m * 60 + s + parseInt(ms) / 1000;
      } catch (e) {
        return 0;
      }
    }

    function parseSrt(content) {
      const segments = [];
      const blocks = content.trim().split(/\n\s*\n/);

      for (const block of blocks) {
        const lines = block.split('\n').map(l => l.trim()).filter(l => l);
        if (lines.length < 2) continue;

        // Find timestamp line (-->)
        let timeLineIdx = -1;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes('-->')) {
            timeLineIdx = i;
            break;
          }
        }

        if (timeLineIdx === -1) continue;

        const timeLine = lines[timeLineIdx];
        const text = lines.slice(timeLineIdx + 1).join(' ').replace(/<[^>]+>/g, ''); // strip html tags

        try {
          const [startStr, endStr] = timeLine.split(' --> ');
          segments.push({
            start: parseTime(startStr),
            end: parseTime(endStr),
            text: text
          });
        } catch (e) {
          console.error("Error parsing block", block);
        }
      }
      return segments;
    }

    async function startTTS() {
      const urlInput = document.getElementById('tts-url');
      const apiUrl = urlInput.value.replace(/\/$/, '');

      if (!apiUrl) {
        alert('è¯·è¾“å…¥ TTS æœåŠ¡å™¨åœ°å€');
        return;
      }

      if (!refAudioFile) {
        alert('è¯·ä¸Šä¼ å‚è€ƒéŸ³é¢‘');
        return;
      }

      if (srtSegments.length === 0) {
        alert('è¯·ä¸Šä¼ æœ‰æ•ˆçš„ SRT å­—å¹•æ–‡ä»¶');
        return;
      }

      // Save URL
      localStorage.setItem('tts_api_url', apiUrl);

      const btn = document.getElementById('tts-start-btn');
      btn.disabled = true;
      btn.textContent = 'ç”Ÿæˆä¸­...';

      const statusText = document.getElementById('tts-status-text');
      const progressText = document.getElementById('tts-progress-text');
      const progressBar = document.getElementById('tts-progress-bar');
      const logText = document.getElementById('tts-log-text');
      const errorMsg = document.getElementById('tts-error-msg');
      const downloadLink = document.getElementById('tts-download-link');
      const resultPlayerContainer = document.getElementById('tts-result-container');

      document.getElementById('tts-progress-container').style.display = 'block';
      errorMsg.textContent = '';
      downloadLink.style.display = 'none';
      resultPlayerContainer.style.display = 'none';

      try {
        // 1. Upload Ref Audio
        logText.textContent = "æ­£åœ¨ä¸Šä¼ å‚è€ƒéŸ³é¢‘...";
        const formData = new FormData();
        formData.append('audio', refAudioFile);
        formData.append('full_path', refAudioFile.name);

        const uploadResp = await fetch(`${apiUrl}/v1/upload_audio`, {
          method: 'POST',
          body: formData
        });

        if (!uploadResp.ok) {
           throw new Error(`ä¸Šä¼ å‚è€ƒéŸ³é¢‘å¤±è´¥: ${uploadResp.status} ${uploadResp.statusText}`);
        }

        // 2. Synthesize Segments
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffers = [];

        let nextAvailableTime = 0;

        for (let i = 0; i < srtSegments.length; i++) {
          const seg = srtSegments[i];
          const progress = Math.round(((i) / srtSegments.length) * 80);
          progressBar.style.width = `${progress}%`;
          progressText.textContent = `${progress}%`;
          statusText.textContent = `æ­£åœ¨ç”Ÿæˆç¬¬ ${i+1}/${srtSegments.length} å¥`;
          logText.textContent = seg.text.substring(0, 30) + '...';

          const synthResp = await fetch(`${apiUrl}/v2/synthesize`, {
             method: 'POST',
             headers: {'Content-Type': 'application/json'},
             body: JSON.stringify({
               text: seg.text,
               audio_path: refAudioFile.name // Matches what we uploaded
             })
          });

          if (!synthResp.ok) {
             console.warn(`Failed to synthesize line ${i+1}: ${synthResp.status}`);
             continue;
          }

          const audioBlob = await synthResp.blob();
          const arrayBuffer = await audioBlob.arrayBuffer();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

          // Calculate Timing (Auto-Flow)
          let startTime = seg.start;
          if (startTime < nextAvailableTime) {
             startTime = nextAvailableTime;
             console.log(`Shifted segment ${i} to ${startTime}`);
          }

          audioBuffers.push({
             buffer: audioBuffer,
             startTime: startTime
          });

          nextAvailableTime = startTime + audioBuffer.duration;
        }

        // 3. Render / Mix
        statusText.textContent = "æ­£åœ¨æ··éŸ³...";
        progressBar.style.width = '90%';
        progressText.textContent = '90%';

        if (audioBuffers.length === 0) {
           throw new Error("æ²¡æœ‰ç”Ÿæˆä»»ä½•è¯­éŸ³ç‰‡æ®µ");
        }

        const totalDuration = nextAvailableTime + 1; // Add 1s padding
        const offlineCtx = new OfflineAudioContext(1, totalDuration * 44100, 44100);

        audioBuffers.forEach(({buffer, startTime}) => {
           const source = offlineCtx.createBufferSource();
           source.buffer = buffer;

           // Fade In/Out (50ms)
           const fadeDuration = 0.05;
           const gainNode = offlineCtx.createGain();

           gainNode.gain.setValueAtTime(0, startTime);
           gainNode.gain.linearRampToValueAtTime(1, startTime + fadeDuration);
           gainNode.gain.setValueAtTime(1, startTime + buffer.duration - fadeDuration);
           gainNode.gain.linearRampToValueAtTime(0, startTime + buffer.duration);

           source.connect(gainNode);
           gainNode.connect(offlineCtx.destination);

           source.start(startTime);
        });

        const renderedBuffer = await offlineCtx.startRendering();

        // 4. Encode to WAV
        statusText.textContent = "æ­£åœ¨å¯¼å‡º...";
        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
        const wavUrl = URL.createObjectURL(wavBlob);

        const resultPlayer = document.getElementById('tts-result-player');
        resultPlayer.src = wavUrl;
        resultPlayerContainer.style.display = 'block';

        downloadLink.href = wavUrl;
        downloadLink.download = `tts_output_${Date.now()}.wav`;
        downloadLink.style.display = 'inline-block';

        statusText.textContent = "ç”Ÿæˆå®Œæˆï¼";
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
        btn.disabled = false;
        btn.textContent = 'å¼€å§‹ç”Ÿæˆ';

      } catch (e) {
        console.error(e);
        errorMsg.textContent = 'é”™è¯¯: ' + e.message;
        btn.disabled = false;
        btn.textContent = 'å¼€å§‹ç”Ÿæˆ';
      }
    }

    // Helper: Convert AudioBuffer to WAV Blob
    function bufferToWave(abuffer, len) {
      let numOfChan = abuffer.numberOfChannels,
          length = len * numOfChan * 2 + 44,
          buffer = new ArrayBuffer(length),
          view = new DataView(buffer),
          channels = [], i, sample,
          offset = 0,
          pos = 0;

      // write WAVE header
      setUint32(0x46464952);                         // "RIFF"
      setUint32(length - 8);                         // file length - 8
      setUint32(0x45564157);                         // "WAVE"

      setUint32(0x20746d66);                         // "fmt " chunk
      setUint32(16);                                 // length = 16
      setUint16(1);                                  // PCM (uncompressed)
      setUint16(numOfChan);
      setUint32(abuffer.sampleRate);
      setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
      setUint16(numOfChan * 2);                      // block-align
      setUint16(16);                                 // 16-bit (hardcoded in this example)

      setUint32(0x61746164);                         // "data" - chunk
      setUint32(length - pos - 4);                   // chunk length

      // write interleaved data
      for(i = 0; i < abuffer.numberOfChannels; i++)
        channels.push(abuffer.getChannelData(i));

      while(pos < len) {
        for(i = 0; i < numOfChan; i++) {             // interleave channels
          sample = Math.max(-1, Math.min(1, channels[i][pos])); // clamp
          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
          view.setInt16(44 + offset, sample, true);          // write 16-bit sample
          offset += 2;
        }
        pos++;
      }

      return new Blob([buffer], {type: "audio/wav"});

      function setUint16(data) {
        view.setUint16(pos, data, true);
        pos += 2;
      }

      function setUint32(data) {
        view.setUint32(pos, data, true);
        pos += 4;
      }
    }
  </script>
</body>
</html>
